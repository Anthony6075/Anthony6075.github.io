<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>送别</title>
      <link href="/2025/12/15/%E9%80%81%E5%88%AB/"/>
      <url>/2025/12/15/%E9%80%81%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">送别</p></h1><h3><p style="text-align: center;">[民国] 李叔同</p></h3><h2><p style="text-align: center;">长亭外，古道边，芳草碧连天。</p></h2><h2><p style="text-align: center;">晚风拂柳笛声残，夕阳山外山。</p></h2><h2><p style="text-align: center;">天之涯，地之角，知交半零落。</p></h2><h2><p style="text-align: center;">一瓢浊酒尽余欢，今宵别梦寒。</p></h2><h2><p style="text-align: center;">情千缕，酒一杯，声声离笛催。</p></h2><h2><p style="text-align: center;">问君此去几时来，来时莫徘徊。</p></h2><h2><p style="text-align: center;">草碧色，水绿波，南浦伤如何。</p></h2><h2><p style="text-align: center;">人生难得是欢聚，惟有别离多。</p></h2><hr><p><strong>注</strong>: 被确证出自李叔同之手的词句仅有前四句，但后四句依然语言优美、浑然天成。</p>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赠药山高僧惟俨二首</title>
      <link href="/2025/08/30/%E8%B5%A0%E8%8D%AF%E5%B1%B1%E9%AB%98%E5%83%A7%E6%83%9F%E4%BF%A8%E4%BA%8C%E9%A6%96/"/>
      <url>/2025/08/30/%E8%B5%A0%E8%8D%AF%E5%B1%B1%E9%AB%98%E5%83%A7%E6%83%9F%E4%BF%A8%E4%BA%8C%E9%A6%96/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">赠药山高僧惟俨二首</p></h1><h3><p style="text-align: center;">[唐] 李翱</p></h3><h3><p style="text-align: center;">（其一）</p></h3><h2><p style="text-align: center;">练得身形似鹤形，千株松下两函经。</p></h2><h2><p style="text-align: center;">我来问道无馀说，云在青天水在瓶。</p></h2><h3><p style="text-align: center;">（其二）</p></h3><h2><p style="text-align: center;">选得幽居惬野情，终年无送亦无迎。</p></h2><h2><p style="text-align: center;">有时直上孤峰顶，月下披云啸一声。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桃花庵歌</title>
      <link href="/2025/06/28/%E6%A1%83%E8%8A%B1%E5%BA%B5%E6%AD%8C/"/>
      <url>/2025/06/28/%E6%A1%83%E8%8A%B1%E5%BA%B5%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">桃花庵歌</p></h1><h3><p style="text-align: center;">[明] 唐寅</p></h3><h2><p style="text-align: center;">桃花坞里桃花庵，桃花庵里桃花仙。</p></h2><h2><p style="text-align: center;">桃花仙人种桃树，又折花枝当酒钱。</p></h2><h2><p style="text-align: center;">酒醒只在花前坐，酒醉还须花下眠。</p></h2><h2><p style="text-align: center;">花前花后日复日，酒醉酒醒年复年。</p></h2><h2><p style="text-align: center;">不愿鞠躬车马前，但愿老死花酒间。</p></h2><h2><p style="text-align: center;">车尘马足贵者趣，酒盏花枝贫者缘。</p></h2><h2><p style="text-align: center;">若将富贵比贫贱，一在平地一在天。</p></h2><h2><p style="text-align: center;">若将贫贱比车马，他得驱驰我得闲。</p></h2><h2><p style="text-align: center;">世人笑我忒疯颠，我咲世人看不穿。</p></h2><h2><p style="text-align: center;">记得五陵豪杰墓，无酒无花锄作田。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自遣</title>
      <link href="/2025/04/06/%E8%87%AA%E9%81%A3/"/>
      <url>/2025/04/06/%E8%87%AA%E9%81%A3/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">自遣</p></h1><h3><p style="text-align: center;">[唐] 李群玉</p></h3><h2><p style="text-align: center;">翻覆升沉百岁中，前途一半已成空。</p></h2><h2><p style="text-align: center;">浮生暂寄梦中梦，世事如闻风里风。</p></h2><h2><p style="text-align: center;">修竹万竿资阒寂，古书千卷要穷通。</p></h2><h2><p style="text-align: center;">一壶浊酒暄和景，谁会陶然失马翁。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赠卫八处士</title>
      <link href="/2024/12/03/%E8%B5%A0%E5%8D%AB%E5%85%AB%E5%A4%84%E5%A3%AB/"/>
      <url>/2024/12/03/%E8%B5%A0%E5%8D%AB%E5%85%AB%E5%A4%84%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">赠卫八处士</p></h1><h3><p style="text-align: center;">[唐] 杜甫</p></h3><h2><p style="text-align: center;">人生不相见，动如参与商。</p></h2><h2><p style="text-align: center;">今夕复何夕，共此灯烛光。</p></h2><h2><p style="text-align: center;">少壮能几时，鬓发各已苍。</p></h2><h2><p style="text-align: center;">访旧半为鬼，惊呼热中肠。</p></h2><h2><p style="text-align: center;">焉知二十载，重上君子堂。</p></h2><h2><p style="text-align: center;">昔别君未婚，儿女忽成行。</p></h2><h2><p style="text-align: center;">怡然敬父执，问我来何方。</p></h2><h2><p style="text-align: center;">问答乃未已，驱儿罗酒浆。</p></h2><h2><p style="text-align: center;">夜雨剪春韭，新炊间黄粱。</p></h2><h2><p style="text-align: center;">主称会面难，一举累十觞。</p></h2><h2><p style="text-align: center;">十觞亦不醉，感子故意长。</p></h2><h2><p style="text-align: center;">明日隔山岳，世事两茫茫。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux ps常用命令</title>
      <link href="/2024/12/03/linux-ps-command/"/>
      <url>/2024/12/03/linux-ps-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-查看所有进程"><a href="#1-查看所有进程" class="headerlink" title="1. 查看所有进程"></a>1. 查看所有进程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br></pre></td></tr></table></figure><h1 id="2-查看进程启动时间"><a href="#2-查看进程启动时间" class="headerlink" title="2. 查看进程启动时间"></a>2. 查看进程启动时间</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -eo pid,lstart,cmd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题临安山水</title>
      <link href="/2024/11/26/%E9%A2%98%E4%B8%B4%E5%AE%89%E5%B1%B1%E6%B0%B4/"/>
      <url>/2024/11/26/%E9%A2%98%E4%B8%B4%E5%AE%89%E5%B1%B1%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">题临安山水</p></h1><h3><p style="text-align: center;">[金] 完颜亮</p></h3><h2><p style="text-align: center;">万里车书一混同，江南岂有别疆封？</p></h2><h2><p style="text-align: center;">提兵百万西湖上，立马吴山第一峰！</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB 常用命令</title>
      <link href="/2024/11/26/linux-gdb-command/"/>
      <url>/2024/11/26/linux-gdb-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-编译"><a href="#1-编译" class="headerlink" title="1. 编译"></a>1. 编译</h1><p>注意： </p><ol><li><p><strong>不要使用优化</strong>(即使用-O0选项)</p></li><li><p><strong>带上调试信息</strong>(即使用-g选项)</p></li></ol><p>-g的调试信息级别是2，使用-g3会带上额外调试信息(如关于宏的)</p><p>总而言之，最好使用<code>-g3 -O0</code></p><h1 id="2-help-system"><a href="#2-help-system" class="headerlink" title="2. help system"></a>2. help system</h1><h2 id="2-1-help命令"><a href="#2-1-help命令" class="headerlink" title="2.1 help命令"></a>2.1 <code>help</code>命令</h2><p><code>help</code>缩写为<code>h</code></p><p><code>help &lt;command&gt;</code> 输出某个命令的全部文档</p><h2 id="2-2-apropos命令"><a href="#2-2-apropos命令" class="headerlink" title="2.2 apropos命令"></a>2.2 <code>apropos</code>命令</h2><p><code>apropos [-v] &lt;regexp&gt;</code>遍历所有命令、别名和文档查找<code>&lt;regexp&gt;</code>的匹配</p><h2 id="2-3-其他"><a href="#2-3-其他" class="headerlink" title="2.3 其他"></a>2.3 其他</h2><p><code>complete &lt;args&gt;</code>输出<code>&lt;args&gt;</code>所有可能的命令补全结果</p><p><code>info</code>命令用于获取正在调试的程序的状态信息</p><p><code>show</code>命令用于获取GDB本身的状态信息</p><h1 id="3-启动GDB"><a href="#3-启动GDB" class="headerlink" title="3. 启动GDB"></a>3. 启动GDB</h1><h2 id="3-1-正常启动"><a href="#3-1-正常启动" class="headerlink" title="3.1 正常启动"></a>3.1 正常启动</h2><p>直接指定二进制文件，例如<code>gdb myprogram</code></p><p>或者先不带参数启动GDB再用<code>file</code>命令加载，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) file myprogram</span><br><span class="line">Reading symbols from myprogram...</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>inferior在GDB里基本等同于进程，它可以包含多个线程</p><h2 id="3-2-q或者-quiet"><a href="#3-2-q或者-quiet" class="headerlink" title="3.2 -q或者--quiet"></a>3.2 <code>-q</code>或者<code>--quiet</code></h2><p>启动时不打印GDB版本信息</p><h2 id="3-3-指定被调试程序的命令行参数"><a href="#3-3-指定被调试程序的命令行参数" class="headerlink" title="3.3 指定被调试程序的命令行参数"></a>3.3 指定被调试程序的命令行参数</h2><p>启动后查看程序命令行参数用<code>show args</code>，查看当前函数的参数用<code>info args</code></p><h3 id="3-3-1-args选项"><a href="#3-3-1-args选项" class="headerlink" title="3.3.1 --args选项"></a>3.3.1 <code>--args</code>选项</h3><p>例如<code>gdb --args myprogram 1 2 3</code></p><h3 id="3-3-2-run命令或者start命令"><a href="#3-3-2-run命令或者start命令" class="headerlink" title="3.3.2 run命令或者start命令"></a>3.3.2 run命令或者start命令</h3><p>例如<code>run 1 2 3</code>或者<code>start 1 2 3</code></p><h3 id="3-3-3-set-args命令"><a href="#3-3-3-set-args命令" class="headerlink" title="3.3.3 set args命令"></a>3.3.3 <code>set args</code>命令</h3><p>例如<code>set args 1 2 3</code></p><h2 id="3-4-调试coredump文件"><a href="#3-4-调试coredump文件" class="headerlink" title="3.4 调试coredump文件"></a>3.4 调试coredump文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb &lt;executable_file_path&gt; &lt;coredump_file_path&gt;</span><br></pre></td></tr></table></figure><h1 id="4-GDB常用命令"><a href="#4-GDB常用命令" class="headerlink" title="4. GDB常用命令"></a>4. GDB常用命令</h1><h4 id="1-run和start"><a href="#1-run和start" class="headerlink" title="1. run和start"></a>1. <code>run</code>和<code>start</code></h4><p>运行程序，其中<code>run</code>的缩写为<code>r</code>，<code>start</code>会在main函数开始处暂停</p><h4 id="2-break-LOCATION-thread-THREAD-NUM-if-CONDITION"><a href="#2-break-LOCATION-thread-THREAD-NUM-if-CONDITION" class="headerlink" title="2. break [LOCATION] [thread THREAD_NUM] [if CONDITION]"></a>2. <code>break [LOCATION] [thread THREAD_NUM] [if CONDITION]</code></h4><p>缩写为<code>b</code>，设置断点，可以使用文件名和行号，也可以使用函数名</p><ul><li><p>不指定<code>[LOCATION]</code>的话断点打到正要执行的那一行</p></li><li><p><code>[thread THREAD_NUM]</code>用于限制只有特定线程hit这个断点时程序才会暂停</p></li><li><p><code>if</code>子句用来指定条件断点，只有在<code>CONDITION</code>为真时断点才会触发</p></li><li><p><code>tbreak</code>命令类似于<code>break</code>，只是用来设置临时断点，在第一次hit之后GDB就会自动删除它</p></li></ul><h4 id="3-continue"><a href="#3-continue" class="headerlink" title="3. continue"></a>3. <code>continue</code></h4><p>在断点处继续执行，直到下一个断点</p><h4 id="4-next"><a href="#4-next" class="headerlink" title="4. next"></a>4. <code>next</code></h4><p>缩写为<code>n</code>，step over，(可跟一个数字参数<code>[N]</code>指定重复<code>next</code>的次数，但遇到断点还是会提前stop)</p><h4 id="5-step"><a href="#5-step" class="headerlink" title="5. step"></a>5. <code>step</code></h4><p>缩写为<code>s</code>，step into，(可跟一个数字参数<code>[N]</code>指定重复<code>step</code>的次数，但遇到断点还是会提前stop)</p><h4 id="6-print"><a href="#6-print" class="headerlink" title="6. print"></a>6. <code>print</code></h4><p>缩写为<code>p</code>，打印表达式的值</p><h4 id="7-watch-EXP"><a href="#7-watch-EXP" class="headerlink" title="7. watch EXP"></a>7. <code>watch EXP</code></h4><p>监控表达式<code>EXP</code>，当它的值改变时暂停程序</p><h4 id="8-backtrace或者where"><a href="#8-backtrace或者where" class="headerlink" title="8. backtrace或者where"></a>8. <code>backtrace</code>或者<code>where</code></h4><p>缩写为<code>bt</code>，打印调用栈帧层次</p><h4 id="9-frame"><a href="#9-frame" class="headerlink" title="9. frame"></a>9. <code>frame</code></h4><p>缩写为<code>f</code>，选择并打印栈帧</p><ul><li>不带参数时，打印当前被选择的栈帧，打印结果为(1)第一行为层次相关，(2)第二行为<strong>此栈帧内</strong>正要执行的代码</li><li>指定数字参数，选择到该层栈帧并打印</li><li><code>frame function &lt;function_name&gt;</code>或者缩写为<code>f f &lt;function_name&gt;</code>，通过函数名选择栈帧并打印</li></ul><h4 id="10-finish"><a href="#10-finish" class="headerlink" title="10. finish"></a>10. <code>finish</code></h4><p>缩写为<code>fin</code>，运行到当前函数返回，step out</p><h4 id="11-delete-BREAKPOINT-NUM"><a href="#11-delete-BREAKPOINT-NUM" class="headerlink" title="11. delete [BREAKPOINT_NUM]"></a>11. <code>delete [BREAKPOINT_NUM]</code></h4><ul><li><p>缩写为<code>d</code>，通过断点号<code>BREAKPOINT_NUM</code>删除断点</p></li><li><p>也可以跟其他子命令用以删除其他GDB对象</p></li></ul><h4 id="12-info"><a href="#12-info" class="headerlink" title="12. info"></a>12. <code>info</code></h4><p>缩写为<code>i</code>，用于获取正在调试的程序的状态信息，例如：</p><ul><li><p><code>info breakpoints</code>或者缩写为<code>i b</code>， 查看断点</p></li><li><p><code>info threads</code>或者缩写为<code>i th</code>，查看线程信息</p></li><li><p><code>info shared</code>，查看加载的动态链接库</p></li><li><p><code>info display</code>，查看自动展示表达式</p></li></ul><h4 id="13-shell"><a href="#13-shell" class="headerlink" title="13. shell"></a>13. <code>shell</code></h4><p>将这一行的剩余部分当做shell命令执行，无其余部分时会启动一个shell</p><h4 id="14-清屏"><a href="#14-清屏" class="headerlink" title="14. 清屏"></a>14. 清屏</h4><p>ctrl+L或者<code>shell clear</code></p><h4 id="15-list"><a href="#15-list" class="headerlink" title="15. list"></a>15. <code>list</code></h4><p>缩写为<code>l</code>，列出源代码</p><ul><li><p>无参数时，列出上一次调用后挨着的10行</p></li><li><p><code>list -</code>，列出上一次调用前挨着的10行</p></li><li><p>指定单参数时，列出该行前后共10行</p></li><li><p>指定逗号分隔的双参数时，它们指定了列出的代码范围，如果一个参数是空，以另一个参数为准向前或向后列出10行</p></li><li><p>行号也可以用函数名指定，如<code>l f,</code>列出函数f的前10行，接着调<code>l</code>可以不断向后列出函数f的其他代码</p></li><li><p>可以使用<code>show listsize</code>或者<code>set listsize &lt;size&gt;</code>查看或修改listsize，默认为10行</p></li></ul><h4 id="16-thread"><a href="#16-thread" class="headerlink" title="16. thread &lt;THREAD_NUM&gt;"></a>16. <code>thread &lt;THREAD_NUM&gt;</code></h4><p>缩写为<code>t</code>，切换到线程<code>&lt;THREAD_NUM&gt;</code></p><h4 id="17-until-LINE-SPEC"><a href="#17-until-LINE-SPEC" class="headerlink" title="17. until LINE_SPEC"></a>17. <code>until LINE_SPEC</code></h4><p>缩写为<code>u</code>，(在当前栈帧)执行下去直到<code>LINE_SPEC</code>指定的行，停下来时<code>LINE_SPEC</code>是下一行要执行的</p><ul><li><p>可以用来将循环执行完毕</p></li><li><p>如果<code>LINE_SPEC</code>超出当前函数，只会执行到当前函数返回为止</p></li></ul><h4 id="18-call"><a href="#18-call" class="headerlink" title="18. call"></a>18. <code>call</code></h4><p>调用函数并打印返回值，例如<code>call f(1,2,3)</code></p><h4 id="19-return"><a href="#19-return" class="headerlink" title="19. return [&lt;return_value&gt;]"></a>19. <code>return [&lt;return_value&gt;]</code></h4><p>使当前函数(栈帧)直接返回，如果指定了<code>&lt;return_value&gt;</code>，将它作为函数返回值</p><h4 id="20-display-EXP"><a href="#20-display-EXP" class="headerlink" title="20. display [EXP]"></a>20. <code>display [EXP]</code></h4><ul><li><p>在每次程序暂停时自动打印表达式<code>EXP</code>的值</p></li><li><p>不带参数时，列出当前所有的自动打印表达式</p></li></ul><h4 id="21-undisplay-NUM"><a href="#21-undisplay-NUM" class="headerlink" title="21. undisplay [NUM]"></a>21. <code>undisplay [NUM]</code></h4><ul><li><p>删除<code>NUM</code>标识的自动打印表达式</p></li><li><p>不带参数时，删除所有自动打印表达式</p></li></ul><h4 id="22-disable-BREAKPOINT-NUM"><a href="#22-disable-BREAKPOINT-NUM" class="headerlink" title="22. disable [BREAKPOINT_NUM]"></a>22. <code>disable [BREAKPOINT_NUM]</code></h4><p>缩写为<code>dis</code>，用于disable某个断点</p><ul><li>不带参数时，disable所有断点</li><li>也可以使用子命令来disable其他GDB对象，如<code>disable display [DISPLAY_NUM]</code></li></ul><h4 id="23-enable-BREAKPOINT-NUM"><a href="#23-enable-BREAKPOINT-NUM" class="headerlink" title="23. enable [BREAKPOINT_NUM]"></a>23. <code>enable [BREAKPOINT_NUM]</code></h4><p>缩写为<code>en</code>，和<code>disable</code>命令作用完全相反</p><h4 id="24-clear-LINE-SPEC"><a href="#24-clear-LINE-SPEC" class="headerlink" title="24. clear [LINE_SPEC]"></a>24. <code>clear [LINE_SPEC]</code></h4><p>缩写为<code>cl</code>，用于删除某一行上的断点</p><ul><li>不带参数时，删除当前栈帧的当前行上的断点</li><li><code>LINE_SPEC</code>可以是函数名，删除函数声明行上的断点</li></ul><h4 id="25-set"><a href="#25-set" class="headerlink" title="25. set"></a>25. <code>set</code></h4><ul><li><code>set VAR = EXP</code>，计算表达式<code>EXP</code>并赋值给变量<code>VAR</code></li><li>当<code>VAR</code>变量名和<code>set</code>的子命令名冲突时，可以使用<code>set var VAR = EXP</code>子命令来对变量赋值</li></ul><h4 id="26-up-NUM"><a href="#26-up-NUM" class="headerlink" title="26. up [NUM]"></a>26. <code>up [NUM]</code></h4><ul><li>选择上层栈帧(调用当前函数的函数)</li><li><code>NUM</code>指定向上走几层，默认为1</li></ul><h4 id="27-down-NUM"><a href="#27-down-NUM" class="headerlink" title="27. down [NUM]"></a>27. <code>down [NUM]</code></h4><p>缩写为<code>do</code></p><ul><li>选择下层栈帧(当前函数调用的函数)</li><li><code>NUM</code>指定向下走几层，默认为1</li></ul><h4 id="28-set-history-save-on"><a href="#28-set-history-save-on" class="headerlink" title="28. set history save on"></a>28. <code>set history save on</code></h4><p>在退出时保存命令历史，可以写入<code>~/.gdbinit</code>文件以默认启用命令历史保存</p><h4 id="29-pipe"><a href="#29-pipe" class="headerlink" title="29. pipe"></a>29. <code>pipe</code></h4><p>缩写为<code>|</code>，将gdb命令的输出重定向到一个shell命令，使用方式：</p><p><code>| [COMMAND] | SHELL_COMMAND</code>或者<code>pipe [COMMAND] | SHELL_COMMAND</code></p><h4 id="30-commands-BREAK-NUM"><a href="#30-commands-BREAK-NUM" class="headerlink" title="30. commands [BREAK_NUM]"></a>30. <code>commands [BREAK_NUM]</code></h4><p>设定在指定断点hit时需要执行的命令</p><ul><li><p>无<code>BREAK_NUM</code>参数时，默认使用最后设置的断点(即<code>$bpnum</code>)</p></li><li><p>如需清空上次<code>commands</code>的设置，只需再次调用<code>commands</code>并传入空的命令</p></li><li><p>命令第一行输入<code>silent</code>可以使该断点hit时不打印输出</p></li></ul><h4 id="31-ignore"><a href="#31-ignore" class="headerlink" title="31. ignore &lt;BREAK_NUM&gt; &lt;COUNT&gt;"></a>31. <code>ignore &lt;BREAK_NUM&gt; &lt;COUNT&gt;</code></h4><p>忽略断点<code>BREAK_NUM</code>接下来的<code>COUNT</code>次hit</p><h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h1><h2 id="5-1-获取目标文件的编译flags"><a href="#5-1-获取目标文件的编译flags" class="headerlink" title="5.1 获取目标文件的编译flags"></a>5.1 获取目标文件的编译flags</h2><p>为查看某个目标文件编译时是否启用了优化或者携带调试信息(debuginfo)</p><p>使用命令<code>readelf -w &lt;object_file&gt; | grep producer | head -1</code>查看使用的编译器和编译flags</p><p>检查flags里是否有<code>-O</code>或者<code>-g</code>即可</p><h2 id="5-2-查看复杂程序的编译flags"><a href="#5-2-查看复杂程序的编译flags" class="headerlink" title="5.2 查看复杂程序的编译flags"></a>5.2 查看复杂程序的编译flags</h2><p>对于包含多个翻译单元的复杂程序，需要先从readelf的输出中找到指定的翻译单元，再去查看它的producer属性</p><h1 id="6-调试器的不足"><a href="#6-调试器的不足" class="headerlink" title="6. 调试器的不足"></a>6. 调试器的不足</h1><p>调试器毕竟是对原程序的一种入侵，可能有不可避免的副作用(例如：如果一个线程因为断点而stop，另一个线程因为syscall而阻塞，那么这个syscall可能还没有真实执行完就会早熟地返回)，再加上GDB本身的使用也很复杂，所以总会有想不到的情况，遇到没见过的不熟悉的问题不要心慌，<strong>要想其他办法绕过去</strong>。再者说，技术细节其实并不重要也没人关心，重要的是<strong>完成实际任务</strong>和<strong>与人打交道</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux tmux命令常见用法</title>
      <link href="/2024/10/29/linux-tmux-command/"/>
      <url>/2024/10/29/linux-tmux-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>终端复用器，terminal multiplexer的简称。</p><p>将终端和终端里运行的命令解绑。</p><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><h2 id="2-1-新建会话"><a href="#2-1-新建会话" class="headerlink" title="2.1 新建会话"></a>2.1 新建会话</h2><ul><li><p><code>tmux new </code>: 创建会话，会话名默认为编号：0,1，2…</p></li><li><p><code>tmux new -s &lt;session-name&gt;</code>: 创建会话并指定会话名</p></li></ul><h2 id="2-2-分离会话"><a href="#2-2-分离会话" class="headerlink" title="2.2 分离会话"></a>2.2 分离会话</h2><p><code>Ctrl+b d</code>或者<code>tmux detach</code></p><h2 id="2-3-接入会话"><a href="#2-3-接入会话" class="headerlink" title="2.3 接入会话"></a>2.3 接入会话</h2><p><code>tmux attach -t &lt;session-name&gt;</code></p><h2 id="2-4-切换会话"><a href="#2-4-切换会话" class="headerlink" title="2.4 切换会话"></a>2.4 切换会话</h2><p><code>tmux switch -t &lt;session-name&gt;</code></p><h2 id="2-5-重命名会话"><a href="#2-5-重命名会话" class="headerlink" title="2.5 重命名会话"></a>2.5 重命名会话</h2><p><code>tmux rename-session -t &lt;old-session-name&gt; &lt;new-session-name&gt;</code></p><h2 id="2-6-查看会话"><a href="#2-6-查看会话" class="headerlink" title="2.6 查看会话"></a>2.6 查看会话</h2><p><code>tmux ls</code></p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memory sanitizer</title>
      <link href="/2024/10/10/sanitizer(memory-sanitizer)/"/>
      <url>/2024/10/10/sanitizer(memory-sanitizer)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MemorySanitizer简称msan，用于发现C&#x2F;C++程序中对<strong>未初始化内存</strong>的<strong>读取</strong>。</p><p>msan是比特精度的。</p><p>msan的功能是Valgrind功能的子集，但运行速度更快。</p><p>msan使用stderr打印错误报告</p><p>msan发现错误即报告，而不是等到程序即将结束时统一报告</p><p>msan发现如下bug并报告warning:</p><ol><li><p>在条件分支中使用未初始化的值。</p></li><li><p>使用未初始化的指针进行内存访问。</p></li><li><p>函数返回未初始化的值(这是未定义行为，可以使用<code>-fno-sanitize-memory-param-retval</code>来disable这项检查)。</p></li><li><p>传递未初始化数据到一些libc函数中。</p></li></ol><h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h1><h2 id="2-1-常用使用方法"><a href="#2-1-常用使用方法" class="headerlink" title="2.1 常用使用方法"></a>2.1 常用使用方法</h2><ul><li><p>使用clang编译器</p></li><li><p>使用编译选项<code>-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g</code></p></li><li><p>默认错误报告是fatal的，即发现并报告第一个错误后就退出，如需发现多个错误需使用编译选项<code>-fsanitize-recover=memory</code></p></li></ul><p>例如如下程序a.cc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int* a = new int[10];</span><br><span class="line">  a[5] = 0;</span><br><span class="line"></span><br><span class="line">  if (a[argc]) &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;yes&quot; &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete[] a;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g -fsanitize-recover=memory a.cc</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==118555==WARNING: MemorySanitizer: use-of-uninitialized-value</span><br><span class="line">    #0 0x56274f184578 in main /root/msan/a.cc:7:7</span><br><span class="line">    #1 0x7fe1025c6082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)</span><br><span class="line">    #2 0x56274f10932d in _start (/root/msan/a.out+0x1e32d)</span><br><span class="line"></span><br><span class="line">SUMMARY: MemorySanitizer: use-of-uninitialized-value /root/msan/a.cc:7:7 in main</span><br><span class="line">MemorySanitizer: 1 warnings reported.</span><br></pre></td></tr></table></figure><h2 id="2-2-简单使用方法"><a href="#2-2-简单使用方法" class="headerlink" title="2.2 简单使用方法"></a>2.2 简单使用方法</h2><p>仅使用<code>-fsanitize=memory</code>和<code>-g</code>两个编译选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -fsanitize=memory -g a.cc &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure><h1 id="3-追踪内存分配位置"><a href="#3-追踪内存分配位置" class="headerlink" title="3. 追踪内存分配位置"></a>3. 追踪内存分配位置</h1><p>msan可以追踪未初始化值的内存分配位置并报告。</p><p>启用该追踪需使用编译选项<code>-fsanitize-memory-track-origins</code>。</p><p>该追踪会额外减慢程序速度1.5x~2.5x。</p><p>例如对于上面的程序a.cc：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g -fsanitize-recover=memory -fsanitize-memory-track-origins a.cc</span><br><span class="line">$ ./a.out</span><br><span class="line">==118562==WARNING: MemorySanitizer: use-of-uninitialized-value</span><br><span class="line">    #0 0x5596e037f85b in main /root/msan/a.cc:7:7</span><br><span class="line">    #1 0x7f6a6230d082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)</span><br><span class="line">    #2 0x5596e030432d in _start (/root/msan/a.out+0x1e32d)</span><br><span class="line"></span><br><span class="line">  Uninitialized value was created by a heap allocation</span><br><span class="line">    #0 0x5596e037d109 in operator new[](unsigned long) (/root/msan/a.out+0x97109)</span><br><span class="line">    #1 0x5596e037f666 in main /root/msan/a.cc:4:12</span><br><span class="line">    #2 0x7f6a6230d082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)</span><br><span class="line"></span><br><span class="line">SUMMARY: MemorySanitizer: use-of-uninitialized-value /root/msan/a.cc:7:7 in main</span><br><span class="line">MemorySanitizer: 1 warnings reported.</span><br></pre></td></tr></table></figure><h1 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h1><p>为了更好地使用msan，程序中的<strong>所有代码</strong>都需要被msan插桩(使用<code>-fsanitize=memory</code>编译)，包括链接的库(尤其是c++标准库libc++)。</p><p>否则未插桩的代码会导致msan报告假阳性。</p><p>参考<a href="https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo">该文档</a>使用msan构建c++标准库。</p><h1 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h1><ul><li><a href="https://github.com/google/sanitizers/wiki/MemorySanitizer">https://github.com/google/sanitizers/wiki/MemorySanitizer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> sanitizer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c++ </tag>
            
            <tag> sanitizer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sanitizer工具</title>
      <link href="/2024/10/07/sanitizer/"/>
      <url>/2024/10/07/sanitizer/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Sanitizer系列简介"><a href="#1-Sanitizer系列简介" class="headerlink" title="1. Sanitizer系列简介"></a>1. Sanitizer系列简介</h1><p>中文直译：<br>sanity n. 神志正常，精神健全<br>sanitize v. 消毒<br>sanitizer n. 消毒剂</p><h1 id="2-包含的工具"><a href="#2-包含的工具" class="headerlink" title="2. 包含的工具"></a>2. 包含的工具</h1><h2 id="2-1-AddressSanitizer"><a href="#2-1-AddressSanitizer" class="headerlink" title="2.1 AddressSanitizer"></a>2.1 AddressSanitizer</h2><p>用于发现C&#x2F;C++程序中的内存错误，比如use-after-free和{heap,stack,global}-buffer overflow。</p><h2 id="2-2-LeakSanitizer"><a href="#2-2-LeakSanitizer" class="headerlink" title="2.2 LeakSanitizer"></a>2.2 LeakSanitizer</h2><p>用于发现内存泄漏，已被集成到AddressSanitizer中。</p><h2 id="2-3-ThreadSanitizer"><a href="#2-3-ThreadSanitizer" class="headerlink" title="2.3 ThreadSanitizer"></a>2.3 ThreadSanitizer</h2><p>用于发现C&#x2F;C++和Go程序中的数据竞争(data race)。</p><h2 id="2-4-MemorySanitizer"><a href="#2-4-MemorySanitizer" class="headerlink" title="2.4 MemorySanitizer"></a>2.4 MemorySanitizer</h2><p>用于发现未初始化内存的使用。</p><h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h1><ul><li><p>并不是一定能检测出所有的bug ! ! !</p></li><li><p>asan&#x2F;tsan&#x2F;msan在同一个程序中最多使用一个</p></li></ul><h1 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h1><ul><li><p><a href="https://github.com/google/sanitizers/wiki">https://github.com/google/sanitizers/wiki</a></p></li><li><p><a href="https://clang.llvm.org/docs/UsersManual.html#cmdoption-f-no-sanitize">https://clang.llvm.org/docs/UsersManual.html#cmdoption-f-no-sanitize</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> sanitizer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c++ </tag>
            
            <tag> sanitizer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux less命令常见用法</title>
      <link href="/2024/10/06/linux-less-command/"/>
      <url>/2024/10/06/linux-less-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ol><li><p>类似于<code>more</code>命令，但除了向前(下)移动也允许向后(上)移动</p></li><li><p>不会在启动时读入整个输入文件，因此比<code>vi</code>启动更快</p></li><li><p><code>less</code>的命令基于<code>more</code>和<code>vi</code></p></li><li><p><code>less</code>的命令前可以加一个十进制数<code>N</code>，某些命令可以使用它</p></li></ol><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><ol><li><p><code>h</code>或<code>H</code>: 显示命令帮助信息</p></li><li><p><code>q</code>: 退出less</p></li><li><p><code>&lt;SPACE&gt;</code>: 前进(向下)N行，默认一个window</p></li><li><p><code>b</code>: 后退N行，默认一个window</p></li><li><p><code>&lt;ENTER&gt;</code>或<code>j</code>: 前进N行，默认1</p></li><li><p><code>k</code>或<code>y</code>: 后退N行，默认1</p></li><li><p><code>d</code>: 前进N行，默认半个window；如果指定了N，它成为后续<code>d</code>和<code>u</code>命令的默认值</p></li><li><p><code>u</code>: 后退N行，默认半个window；如果指定了N，它成为后续<code>d</code>和<code>u</code>命令的默认值</p></li><li><p><code>R</code>: 重新加载当前文件；在查看的当前文件被改变时很有用</p></li><li><p><code>F</code>: 前进至文件结尾并保持继续读文件(类似于<code>tail -f</code>)，按<code>^C</code>停止等待文件生长</p></li><li><p><code>g</code>: 跳转到第N行，默认第1行；如果N很大这个命令可能很慢</p></li><li><p><code>G</code>: 跳转到第N行，默认最后一行；如果N很大这个命令可能很慢</p></li><li><p><code>p</code>或<code>%</code>: 跳转到<code>N%</code>位置处，N的取值范围为<code>[0, 100]</code>，且可以包含小数</p></li><li><p><code>/pattern</code>: 向前(下)查找第<code>N</code>个包含<code>pattern</code>的行，<code>N</code>默认为1</p><ol><li><code>pattern</code>是正则表达式</li><li>默认查找是大小写敏感的</li><li>查找从屏幕上显示的第一行开始</li><li>可以在<code>pattern</code>的开头包含以下字符来改变查找行为：<ul><li><code>!</code>： 查找不匹配<code>pattern</code>的行</li></ul></li></ol></li><li><p><code>?pattern</code>: 向后(上)查找第<code>N</code>个包含<code>pattern</code>的行</p><ol><li>查找从屏幕上显示的最后一行开始</li><li>可以在<code>pattern</code>的开头包含以下字符来改变查找行为：<ul><li><code>!</code>： 查找不匹配<code>pattern</code>的行</li></ul></li></ol></li><li><p><code>n</code>: 重复先前的查找(查找第<code>N</code>个包含先前的<code>pattern</code>的行)</p></li><li><p><code>N</code>: 以相反方向重复先前的查找</p></li><li><p><code>&amp;pattern</code>: 只显示匹配<code>pattern</code>的行，不匹配的行会被隐藏</p><ol><li>如果<code>pattern</code>为空，先前的过滤都会被关闭，即重新显示所有行</li><li>在过滤正在生效时，prompt的开头会显示一个<code>&amp;</code>符号</li><li>输入多个<code>&amp;pattern</code>命令时，只有匹配所有<code>pattern</code>的行才会显示</li></ol></li><li><p><code>-</code>: 紧跟一个命令行选项字母，这会打印该命令行选项的描述并使用该命令行选项的设置</p></li><li><p><code>-+</code>: 紧跟一个命令行选项字母，这会重置该选项对应的配置为默认配置</p></li><li><p><code>--</code>: 类似于<code>-</code>命令，但是接受一个长选项名</p></li></ol><h1 id="3-常用命令行选项"><a href="#3-常用命令行选项" class="headerlink" title="3. 常用命令行选项"></a>3. 常用命令行选项</h1><p>大部分命令行选项也可以在less运行时通过<code>-</code>命令使用。</p><p>第一次输入某选项enable它，第二次再输入会switch back(即disable)。</p><ol><li><p><code>-M</code>和<code>-m</code>: <code>-m</code>让less使用详细prompt(提示当前页面在文件的百分比位置), <code>-M</code>使用的prompt更加详细。</p></li><li><p><code>-N</code>和<code>-n</code>: <code>-N</code>在每一行开头显示行号，<code>-n</code>取消显示行号。</p></li><li><p><code>-r</code>: 使less解析显示控制字符，用于显示文本颜色、中文字符等。默认情况下less只以<code>^</code>记号显示控制字符。<strong>不推荐使用</strong><code>-r</code>，因为这些控制字符的干扰可能使less出现各种显示问题。</p></li><li><p><code>-i</code>: 使search忽略大小写。但如果<code>pattern</code>里包含任意大写字母，search依然区分大小写。</p></li><li><p><code>-I</code>: 使search忽略大小写(即使<code>pattern</code>里包含大写字母)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>address sanitizer</title>
      <link href="/2024/09/28/sanitizer(address-sanitizer)/"/>
      <url>/2024/09/28/sanitizer(address-sanitizer)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>AddressSantizer简称为asan。</p><p>用于发现C&#x2F;C++程序中的内存错误。</p><p>asan运行很快，它给程序带来的平均slowdown大约2x。</p><p>asan包括两部分：</p><ol><li><p>静态插桩模块(compiler instrumentation module, 目前实现是一个LLVM pass)</p></li><li><p>运行时库(提供了asan版本的malloc、free等函数)</p></li></ol><p>插桩(instrumentation)即修改程序以便于对它进行分析。</p><p>编译器插桩技术是一种在源代码被编译为可执行代码的过程中，向代码中添加额外的指令或元数据的方法。</p><h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h1><h2 id="2-1-编译器版本要求"><a href="#2-1-编译器版本要求" class="headerlink" title="2.1 编译器版本要求"></a>2.1 编译器版本要求</h2><p>llvm 3.1及以上，gcc 4.8及以上</p><h2 id="2-2-常见使用过程"><a href="#2-2-常见使用过程" class="headerlink" title="2.2 常见使用过程"></a>2.2 常见使用过程</h2><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fsanitize=address -O1 -fno-omit-frame-pointer -g use-after-free.c -o use-after-free</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./use-after-free</span><br></pre></td></tr></table></figure><p>即：</p><ul><li><p>使用clang编译器。</p></li><li><p>编译时指定<code>-fsanitize=address</code>选项。</p></li><li><p>为了更高的性能，编译时指定<code>-O1</code>或者更高的优化等级。</p></li><li><p>为了错误信息中更好的stack traces，编译时指定<code>-fno-omit-frame-pointer</code>选项。</p></li><li><p>为了使stack traces里显示函数名和文件名，而不只是函数地址，需要：(1)编译时，指定<code>-g</code>选项；（2）运行时，<code>llvm-symbolizer</code>命令需在<code>PATH</code>环境变量中，或者使用<code>ASAN_SYMBOLIZER_PATH</code>环境变量指定<code>llvm-symbolizer</code>命令的路径。</p></li></ul><h2 id="2-3-简单使用过程"><a href="#2-3-简单使用过程" class="headerlink" title="2.3 简单使用过程"></a>2.3 简单使用过程</h2><p>仅使用<code>-fsanitize=address</code>和<code>-g</code>两个编译选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fsanitize=address -g a.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure><h2 id="2-4-报告第一个错误后继续运行"><a href="#2-4-报告第一个错误后继续运行" class="headerlink" title="2.4 报告第一个错误后继续运行"></a>2.4 报告第一个错误后继续运行</h2><p>默认asan发现第一个错误后退出程序。</p><p>若要报告第一个错误后继续运行，使用编译时flag<code>-fsanitize-recover=address</code>和运行时flag<code>ASAN_OPTIONS=halt_on_error=0</code>。</p><p>例如使用如下编译运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fsanitize=address -fno-omit-frame-pointer -fsanitize-recover=address -g a.c</span><br><span class="line">$ ASAN_OPTIONS=halt_on_error=0 ./a.out</span><br></pre></td></tr></table></figure><h1 id="3-编译时flags和运行时flags"><a href="#3-编译时flags和运行时flags" class="headerlink" title="3. 编译时flags和运行时flags"></a>3. 编译时flags和运行时flags</h1><p>所有flags查看<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">asan flags官方文档</a></p><h2 id="3-1-编译时flags"><a href="#3-1-编译时flags" class="headerlink" title="3.1 编译时flags"></a>3.1 编译时flags</h2><p>常用编译时flags：</p><table><thead><tr><th>flag</th><th>描述</th></tr></thead><tbody><tr><td><code>-fsanitize=address</code></td><td>启用asan</td></tr><tr><td><code>-fno-omit-frame-pointer</code></td><td>Leave frame pointers. Allows the fast unwinder to function properly.</td></tr><tr><td><code>-fsanitize-blacklist=path</code></td><td>用于关闭部分编译时插桩</td></tr></tbody></table><h2 id="3-2-运行时flags"><a href="#3-2-运行时flags" class="headerlink" title="3.2 运行时flags"></a>3.2 运行时flags</h2><p>大部分运行时flags通过环境变量<code>ASAN_OPTIONS</code>传递，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASAN_OPTIONS=verbosity=1:malloc_context_size=20 ./a.out</span><br></pre></td></tr></table></figure><p>为了确定特定版本的asan支持的运行时flag，可以按如下方式运行binary：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASAN_OPTIONS=help=1 ./a.out</span><br></pre></td></tr></table></figure><h1 id="4-调用栈-stack-traces"><a href="#4-调用栈-stack-traces" class="headerlink" title="4. 调用栈(stack traces)"></a>4. 调用栈(stack traces)</h1><p>asan在下面事件发生时打印调用栈：</p><ul><li><p><code>malloc</code>和<code>free</code>函数调用时</p></li><li><p>线程创建时</p></li><li><p>failure</p></li></ul><p>默认情况下，asan使用<code>llvm-symbolizer</code>命令来符号化调用栈中的地址(将其转为函数名和在源文件中的位置)。因此运行时<code>llvm-symbolizer</code>命令需在<code>PATH</code>环境变量中，或者使用<code>ASAN_SYMBOLIZER_PATH</code>环境变量指定<code>llvm-symbolizer</code>命令的路径。</p><h1 id="5-关闭部分插桩"><a href="#5-关闭部分插桩" class="headerlink" title="5. 关闭部分插桩"></a>5. 关闭部分插桩</h1><p>可以使asan忽略某些函数，以加速程序运行，比如这些函数：</p><ul><li><p>非常热且已知正确的函数</p></li><li><p>底层且并不关心的函数</p></li><li><p>具有已知问题的函数</p></li></ul><p>在Clang (3.3+)和GCC (4.8+)可以使用属性<code>no_sanitize_address</code>使asan忽略某个函数，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__clang__) || defined (__GNUC__)</span><br><span class="line"># define ATTRIBUTE_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))</span><br><span class="line">#else</span><br><span class="line"># define ATTRIBUTE_NO_SANITIZE_ADDRESS</span><br><span class="line">#endif</span><br><span class="line">...</span><br><span class="line">ATTRIBUTE_NO_SANITIZE_ADDRESS</span><br><span class="line">void ThisFunctionWillNotBeInstrumented() &#123;...&#125;</span><br></pre></td></tr></table></figure><p>也可以使用编译flag<code>-fsanitize-blacklist=my_ignores.txt</code>通过黑名单文件指定要忽略的函数，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 明确忽略该函数</span><br><span class="line">fun:MyFooBar</span><br><span class="line"># 忽略包含MyFooBar的函数</span><br><span class="line">fun:*MyFooBar*</span><br></pre></td></tr></table></figure><h1 id="6-gdb调试asan程序"><a href="#6-gdb调试asan程序" class="headerlink" title="6. gdb调试asan程序"></a>6. gdb调试asan程序</h1><p>在gdb中使用<strong>常规方式</strong>调试使用asan编译的程序即可。</p><p>当asan发现了bug，它会调用<code>__asan_report_&#123;load,store&#125;&#123;1,2,4,8,16&#125;</code>中的某个函数，这些函数内部会调用<code>__asan::ReportGenericError</code>。</p><p>如果想要gdb在asan报告错误<strong>之前</strong>stop，只需在<code>__asan::ReportGenericError</code>设置断点。</p><p>如果想要gdb在asan报告错误<strong>之后</strong>stop，只需在<code>__sanitizer::Die</code>设置断点，或者使用<code>ASAN_OPTIONS=abort_on_error=1</code>。</p><p>在gdb中还可以使用如下方式让asan描述某个内存位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set overload-resolution off</span><br><span class="line">(gdb) p __asan_describe_address(0x7ffff73c3f80)</span><br><span class="line">0x7ffff73c3f80 is located 0 bytes inside of 10-byte region [0x7ffff73c3f80,0x7ffff73c3f8a)</span><br><span class="line">freed by thread T0 here: </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="7-可以发现的内存bug"><a href="#7-可以发现的内存bug" class="headerlink" title="7. 可以发现的内存bug"></a>7. 可以发现的内存bug</h1><p>可以发现的内存bug包括：</p><ol><li><p>heap-use-after-free</p></li><li><p>heap-buffer-overflow</p></li><li><p>stack-buffer-overflow</p></li><li><p>global-buffer-overflow</p></li><li><p>stack-use-after-return</p></li><li><p>stack-use-after-scope</p></li><li><p>initialization-order-fiasco</p></li><li><p>memory leaks</p></li></ol><h2 id="7-1-heap-use-after-free"><a href="#7-1-heap-use-after-free" class="headerlink" title="7.1 heap-use-after-free"></a>7.1 heap-use-after-free</h2><p>Use after free也称dangling pointer dereference，悬垂指针。</p><p>即使用已经被<code>delete</code>的指针。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  int *array = new int[100];</span><br><span class="line">  delete [] array;</span><br><span class="line">  return array[argc];  // BOOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-heap-buffer-overflow"><a href="#7-2-heap-buffer-overflow" class="headerlink" title="7.2 heap-buffer-overflow"></a>7.2 heap-buffer-overflow</h2><p>Heap buffer overflow即访问到分配的内存区域的外面。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  int *array = new int[100];</span><br><span class="line">  array[0] = 0;</span><br><span class="line">  int res = array[argc + 100];  // BOOM</span><br><span class="line">  delete [] array;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-stack-buffer-overflow"><a href="#7-3-stack-buffer-overflow" class="headerlink" title="7.3 stack-buffer-overflow"></a>7.3 stack-buffer-overflow</h2><p>Stack buffer overflow即访问到栈上buffer的外面。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  int stack_array[100];</span><br><span class="line">  stack_array[1] = 0;</span><br><span class="line">  return stack_array[argc + 100];  // BOOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-global-buffer-overflow"><a href="#7-4-global-buffer-overflow" class="headerlink" title="7.4 global-buffer-overflow"></a>7.4 global-buffer-overflow</h2><p>Global buffer overflow即访问到全局buffer的外面。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int global_array[100] = &#123;-1&#125;;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  return global_array[argc + 100];  // BOOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-stack-use-after-return"><a href="#7-5-stack-use-after-return" class="headerlink" title="7.5 stack-use-after-return"></a>7.5 stack-use-after-return</h2><p>Use after return即使用已经返回的函数的本地变量。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int *ptr;</span><br><span class="line">__attribute__((noinline))</span><br><span class="line">void FunctionThatEscapesLocalObject() &#123;</span><br><span class="line">  int local[100];</span><br><span class="line">  ptr = &amp;local[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">  FunctionThatEscapesLocalObject();</span><br><span class="line">  return ptr[argc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下asan不发现这类stack-use-after-return错误，但它仍可能偶尔发现此类错误却报告为stack-buffer-overflow。</p><p>使用<code>ASAN_OPTIONS=detect_stack_use_after_return=1</code>使asan发现此类错误。</p><p>发现stack-use-after-return在CPU和RAM消耗上比较昂贵，官方benchmark表明最多可造成2x slowdown。</p><p>注意：发现stack-use-after-return需要在heap上分配fake stack，因此可能对low-level code带来兼容性问题，比如对函数的本地变量取地址可能发现它不在栈上。</p><h2 id="7-6-stack-use-after-scope"><a href="#7-6-stack-use-after-scope" class="headerlink" title="7.6 stack-use-after-scope"></a>7.6 stack-use-after-scope</h2><p>Use after scope即在定义某个局部变量的作用域之外使用它。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile int *p = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    p = &amp;x;</span><br><span class="line">  &#125;</span><br><span class="line">  *p = 5;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个检查默认是启用的，如果不需要可以在编译时指定<code>-fno-sanitize-address-use-after-scope</code>。</p><h2 id="7-7-initialization-order-fiasco"><a href="#7-7-initialization-order-fiasco" class="headerlink" title="7.7 initialization-order-fiasco"></a>7.7 initialization-order-fiasco</h2><p>位于不同翻译单元的全局变量的初始化顺序是不确定的。</p><p>如果位于x.cpp中的全局变量x的初始化依赖于位于y.cpp中的全局变量y的初始化，但x却先于y执行初始化，就会出现bug。</p><p>这种bug不一定必现，因此难以定位。</p><p>例如：</p><p>a.cc代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">extern int y;</span><br><span class="line"></span><br><span class="line">int __attribute__((noinline)) read_y() &#123;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int x = read_y() + 1;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;%d\n&quot;, x);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.cc代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo() &#123;</span><br><span class="line">  return 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int y = foo();</span><br></pre></td></tr></table></figure><p>不同的编译命令得到的结果不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ a.cc b.cc &amp;&amp; ./a.out</span><br><span class="line">1</span><br><span class="line">$ clang++ b.cc a.cc &amp;&amp; ./a.out</span><br><span class="line">43</span><br></pre></td></tr></table></figure><p>这种问题称为<a href="https://isocpp.org/wiki/faq/ctors#static-init-order">static initialization order problem</a>。</p><p>解决方案为<a href="https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use">Construct On First Use Idiom</a>，即：将全局变量包装到一个函数内部，成为该函数的static local变量，这样它会且只会在第一次使用时被构造，但需要注意<a href="https://isocpp.org/wiki/faq/ctors#construct-on-first-use-v2">该static local变量需要使用指针</a>。</p><h3 id="7-7-1-启用检查"><a href="#7-7-1-启用检查" class="headerlink" title="7.7.1 启用检查"></a>7.7.1 启用检查</h3><p>asan默认不启用此类bug的检查，若想启用需指定如下运行时flag。</p><ol><li>宽松检查</li></ol><p>启用宽松检查需使用运行时flag<code>ASAN_OPTIONS=check_initialization_order=true</code>。</p><p>如果某个翻译单元中的某个全局变量的初始化，访问了另一个翻译单元中的<strong>未初始化的需动态初始化</strong>的全局变量，宽松检查会进行报告。</p><ol start="2"><li>严格检查</li></ol><p>启用严格检查需指定两个运行时flags<code>ASAN_OPTIONS=check_initialization_order=true:strict_init_order=true</code>。</p><p>如果某个翻译单元中的某个全局变量的初始化，访问了另一个翻译单元中的<strong>需动态初始化的</strong>全局变量，严格检查会进行报告。</p><p>也就是说，宽松检查只会报告真正存在的问题，但严格检查也会报告潜在的问题。</p><h3 id="7-7-2-假阳性"><a href="#7-7-2-假阳性" class="headerlink" title="7.7.2 假阳性"></a>7.7.2 假阳性</h3><ol><li>宽松检查</li></ol><p>对于初始化之前仍然能安全访问(例如，它的构造器do nothing的情况)的需动态初始化的全局变量，宽松检查的报告可能是假阳性的。</p><ol start="2"><li>严格检查</li></ol><p>如果访问的另一个翻译单元中的动态初始化的全局变量已经被初始化了(而且编程者对此已有预期)，或者编程者已经通过某种方式(例如使用动态库)保证了想要的特定的初始化顺序，但严格检查仍然会报告错误，此时就是假阳性。</p><h3 id="7-7-3-忽略某些全局变量的检查"><a href="#7-7-3-忽略某些全局变量的检查" class="headerlink" title="7.7.3 忽略某些全局变量的检查"></a>7.7.3 忽略某些全局变量的检查</h3><p>使用编译选项<code>-fsanitize-blacklist=path/to/blacklist.txt</code>忽略某些全局变量的初始化顺序bug检查。</p><p><code>blacklist.txt</code>文件格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 单个变量</span><br><span class="line">global:bad_variable=init</span><br><span class="line"># 某个类型的全部变量</span><br><span class="line">type:Namespace::ClassName=init</span><br><span class="line"># 给定文件中的全部变量</span><br><span class="line">src:path/to/bad/files/*=init</span><br></pre></td></tr></table></figure><h3 id="7-7-4-性能影响"><a href="#7-7-4-性能影响" class="headerlink" title="7.7.4 性能影响"></a>7.7.4 性能影响</h3><p>初始化顺序bug检查会拖慢程序启动速度。</p><p>它的复杂度为O(NM)，其中N是二进制可执行文件中需动态初始化的全局变量的数量，M是翻译单元的数量。</p><h3 id="7-7-5-注意"><a href="#7-7-5-注意" class="headerlink" title="7.7.5 注意"></a>7.7.5 注意</h3><p>根据<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerInitializationOrderFiasco">asan官方文档</a>学习并跑InitializationOrderFiasco样例过程中发现的奇怪现象：</p><ol><li><p>指定asan相关编译选项后，不同翻译单元的初始化顺序可能改变</p></li><li><p>宽松检查和严格检查似乎没有区别(即使没有指定<code>strict_init_order=true</code>似乎也是严格检查，可能是版本问题)</p></li><li><p>如果x的初始化依赖于y的初始化，那么<code>-fsanitize-blacklist</code>中指定x或者y，错误报告都会disable</p></li><li><p>文档中忽略变量使用<code>-fsanitize-ignorelist</code>，但实验证明<code>-fsanitize-blacklist</code>也可，且较低版本clang<strong>支持后者</strong>不支持前者</p></li></ol><h2 id="7-8-memory-leaks"><a href="#7-8-memory-leaks" class="headerlink" title="7.8 memory leaks"></a>7.8 memory leaks</h2><p>内存泄漏。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void *p;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  p = malloc(7);</span><br><span class="line">  p = 0; // The memory is leaked here.</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>asan已集成<a href="https://anthony6075.github.io/2024/09/23/sanitizer(leak-sanitizer)/">Leak Sanitizer</a>进行内存泄漏检查。</p><h2 id="7-9-总结"><a href="#7-9-总结" class="headerlink" title="7.9 总结"></a>7.9 总结</h2><p>若想启用尽量多的检查，需要额外指定的flags包括：</p><ol><li><p>编译时flags</p></li><li><p>运行时flags</p></li></ol><ul><li><p><code>ASAN_OPTIONS=detect_stack_use_after_return=1</code>启用<code>stack-use-after-return</code></p></li><li><p><code>ASAN_OPTIONS=check_initialization_order=true:strict_init_order=true</code>启用<code>initialization-order-fiasco</code></p></li></ul><h1 id="8-注意"><a href="#8-注意" class="headerlink" title="8. 注意"></a>8. 注意</h1><h2 id="8-1-error-report输出"><a href="#8-1-error-report输出" class="headerlink" title="8.1 error report输出"></a>8.1 error report输出</h2><ul><li><p>asan使用stderr输出error report。</p></li><li><p>asan发现错误立即报告，内存泄漏lsan只在进程最后才报告。</p></li><li><p>每一条error report以<code>==========</code>行开头。</p></li></ul><h2 id="8-2-虚拟内存消耗"><a href="#8-2-虚拟内存消耗" class="headerlink" title="8.2 虚拟内存消耗"></a>8.2 虚拟内存消耗</h2><p>asan会消耗很大的虚拟内存(x86_64 linux上约为20 TB)(不是物理内存)。</p><h2 id="8-3-报告第一个错误后继续运行"><a href="#8-3-报告第一个错误后继续运行" class="headerlink" title="8.3 报告第一个错误后继续运行"></a>8.3 报告第一个错误后继续运行</h2><p>默认模式下asan只会报告第一个错误然后调用<code>_exit()</code>退出程序。</p><p>continue-after-error模式下asan不会在发现错误时退出程序。</p><p>为了启用continue-after-error模式，使用编译时flag<code>-fsanitize-recover=address</code>和运行时flag<code>ASAN_OPTIONS=halt_on_error=0</code>。</p><p>但需要注意continue-after-error模式可能不如默认模式可靠性高，且除了第一个之外的其他错误可能不准确。</p><h2 id="8-4-更激进的错误检查"><a href="#8-4-更激进的错误检查" class="headerlink" title="8.4 更激进的错误检查"></a>8.4 更激进的错误检查</h2><p>使用如下编译时flags和运行时flags：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -fsanitize-address-use-after-scope</span><br><span class="line">ASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1:check_initialization_order=1:strict_init_order=1</span><br></pre></td></tr></table></figure><h2 id="8-5-静态链接"><a href="#8-5-静态链接" class="headerlink" title="8.5 静态链接"></a>8.5 静态链接</h2><p>asan不能用于静态链接。</p><h2 id="8-6-混用clang和gcc"><a href="#8-6-混用clang和gcc" class="headerlink" title="8.6 混用clang和gcc"></a>8.6 混用clang和gcc</h2><p><strong>No.</strong></p><p>clang和gcc有完全不兼容的asan实现，不要在编译链接运行的任何过程中混用clang和gcc。</p><h1 id="9-参考文献"><a href="#9-参考文献" class="headerlink" title="9. 参考文献"></a>9. 参考文献</h1><ul><li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">https://github.com/google/sanitizers/wiki/AddressSanitizer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> sanitizer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c++ </tag>
            
            <tag> sanitizer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leak sanitizer</title>
      <link href="/2024/09/27/sanitizer(leak-sanitizer)/"/>
      <url>/2024/09/27/sanitizer(leak-sanitizer)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li><p>简称LSan</p></li><li><p>用于发现内存泄漏</p></li><li><p>已集成到asan中</p></li><li><p>在性能关键的场景中，LSan也可以在无asan插桩时使用</p></li></ul><h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h1><h2 id="2-1-using-lsan-on-top-of-asan"><a href="#2-1-using-lsan-on-top-of-asan" class="headerlink" title="2.1 using lsan on top of asan"></a>2.1 using lsan on top of asan</h2><p>像使用asan那样使用，例如a.c存在内存泄漏问题，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void *p;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  p = malloc(7);</span><br><span class="line">  p = 0; // The memory is leaked here.</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下方式编译运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fsanitize=address -g a.c -o a &amp;&amp; ./a</span><br></pre></td></tr></table></figure><p>如果使用asan编译的程序不需检查内存泄漏(只需检查其他asan bugs)，则使用运行时flag<code>ASAN_OPTIONS=detect_leaks=0</code>。</p><h2 id="2-2-lsan单独模式"><a href="#2-2-lsan单独模式" class="headerlink" title="2.2 lsan单独模式"></a>2.2 lsan单独模式</h2><p>如果只需检查内存泄漏且不想被asan拖慢运行速度，可以使用编译时flag<code>-fsanitize=leak</code>而不是<code>-fsanitize=address</code>，此时不会发生编译时插桩。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -fsanitize=leak -g a.c -o a &amp;&amp; ./a</span><br></pre></td></tr></table></figure><p>需要注意的是，相对于lsan单独模式，官方对于using lsan on top of asan的测试更加充分。</p><h1 id="3-运行时flags"><a href="#3-运行时flags" class="headerlink" title="3. 运行时flags"></a>3. 运行时flags</h1><p>所有flags查看<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer#flags">lsan官方文档</a>。</p><p>运行时flags使用环境变量<code>LSAN_OPTIONS</code>指定。</p><p>常用运行时flags包括：</p><table><thead><tr><th>flag</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>exitcode</td><td>23</td><td>如果非0，程序若存在内存泄漏则退出码为该值</td></tr><tr><td>max_leaks</td><td>0</td><td>如果非0，lsan只报告指定数量的top内存泄漏</td></tr><tr><td>suppressions</td><td>(none)</td><td>保存忽略规则的文件路径</td></tr></tbody></table><h1 id="4-忽略某些内存泄漏"><a href="#4-忽略某些内存泄漏" class="headerlink" title="4. 忽略某些内存泄漏"></a>4. 忽略某些内存泄漏</h1><p>使用运行时flag<code>suppressions=s.txt</code>指定保存忽略规则的文件s.txt，该文件中一行对应一条规则(也可以用行首的<code>#</code>号表示注释)。</p><p>每条忽略规则形式为<code>leak:&lt;pattern&gt;</code>。</p><p><code>&lt;pattern&gt;</code>将对某条内存泄漏的stack trace进行子字符串匹配，如果函数名、源文件名或者二进制文件名匹配，这条内存泄漏会被忽略。</p><p><code>&lt;pattern&gt;</code>中也可以使用特殊符号<code>^</code>和<code>$</code>来匹配字符串开始及结束。</p><h1 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h1><ul><li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer">https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> sanitizer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c++ </tag>
            
            <tag> sanitizer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>address sanitizer算法原理</title>
      <link href="/2024/09/26/sanitizer(address-sanitizer-algorithm)/"/>
      <url>/2024/09/26/sanitizer(address-sanitizer-algorithm)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-算法原理精简版-TL-DR"><a href="#1-算法原理精简版-TL-DR" class="headerlink" title="1. 算法原理精简版(TL;DR)"></a>1. 算法原理精简版(TL;DR)</h1><h2 id="1-1-运行时库"><a href="#1-1-运行时库" class="headerlink" title="1.1 运行时库"></a>1.1 运行时库</h2><p>asan运行时库提供了asan版的malloc和free函数。</p><ol><li><p>malloc函数在分配的内存区域周围会再分配redzones内存并在redzones内存投毒(poisoned)。</p></li><li><p>free函数对被释放的内存区域投毒(poisoned)，并将它放到临时隔离队列(quarantine queue)中，使它在一段时间内不会被再malloc。</p></li></ol><h2 id="1-2-插桩"><a href="#1-2-插桩" class="headerlink" title="1.2 插桩"></a>1.2 插桩</h2><p>程序中的内存访问操作会做如下转换：</p><p>转换前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*address = ...;  // or: ... = *address;</span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (IsPoisoned(address)) &#123;</span><br><span class="line">  ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">&#125;</span><br><span class="line">*address = ...;  // or: ... = *address;</span><br></pre></td></tr></table></figure><h1 id="2-内存映射"><a href="#2-内存映射" class="headerlink" title="2. 内存映射"></a>2. 内存映射</h1><h2 id="2-1-内存划分"><a href="#2-1-内存划分" class="headerlink" title="2.1 内存划分"></a>2.1 内存划分</h2><p>整个内存虚拟地址空间被分为不相交的两类：</p><ol><li><p>Mem：被常规应用代码使用的内存区域。</p></li><li><p>Shadow：用于保存元数据(称为shadow values)。</p></li></ol><h2 id="2-2-内存映射"><a href="#2-2-内存映射" class="headerlink" title="2.2 内存映射"></a>2.2 内存映射</h2><p>Mem区域和Shadow区域存在映射关系，Mem对应的具体shadow value表示了其有没有被投毒(poisoned)。</p><p>8字节(1个qword)的Mem对应1字节的Shadow。之所以以8字节为单位映射Mem，是因为malloc返回的内存块都是对齐到8字节的。</p><p>这个1字节shadow value的可能取值及含义包括：</p><ol><li><p>0。这8字节Mem都可用(即未投毒，unpoisoned，addressable)。</p></li><li><p>负值。这8字节Mem都不可用(即都被投毒，poisoned，not addressable)。</p></li><li><p>[1, 7]之间的正整数<code>k</code>。前<code>k</code>字节可用未投毒，后<code>8-k</code>字节被投毒不可用。这种情况只会发生在malloc分配的内存区域尾部。</p></li></ol><h2 id="2-3-具体映射关系"><a href="#2-3-具体映射关系" class="headerlink" title="2.3 具体映射关系"></a>2.3 具体映射关系</h2><p>映射函数<code>MemToShadow</code>具体为：</p><ul><li><p>64位平台上：<code>Shadow = (Mem &gt;&gt; 3) + 0x7fff8000;</code>。</p></li><li><p>32位平台上：<code>Shadow = (Mem &gt;&gt; 3) + 0x20000000;</code>。</p></li></ul><h1 id="3-插桩"><a href="#3-插桩" class="headerlink" title="3. 插桩"></a>3. 插桩</h1><p>插桩代码可进一步表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">byte *shadow_address = MemToShadow(address);</span><br><span class="line">byte shadow_value = *shadow_address;</span><br><span class="line">if (shadow_value) &#123;</span><br><span class="line">  if (SlowPathCheck(shadow_value, address, kAccessSize)) &#123;</span><br><span class="line">    ReportError(address, kAccessSize, kIsWrite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Check the cases where we access first k bytes of the qword</span><br><span class="line">// and these k bytes are unpoisoned.</span><br><span class="line">bool SlowPathCheck(shadow_value, address, kAccessSize) &#123;</span><br><span class="line">  last_accessed_byte = (address &amp; 7) + kAccessSize - 1;</span><br><span class="line">  return (last_accessed_byte &gt;= shadow_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意<code>MemToShadow(ShadowAddr)</code>会落到<code>ShadowGap</code>区域，<code>ShadowGap</code>是unaddressable，因此在程序代码里直接访问<code>ShadowAddr</code>会导致crash。</p><h1 id="4-运行时库"><a href="#4-运行时库" class="headerlink" title="4. 运行时库"></a>4. 运行时库</h1><p>asan运行时库提供了自己的<code>malloc</code>&#x2F;<code>free</code>函数和错误报告函数(如<code>__asan_report_load8</code>)。</p><ol><li><p><code>malloc</code>函数除了分配指定大小的内存区域，还在这块区域周围分配了redzones内存；前者没有投毒，后者会被投毒。</p></li><li><p><code>free</code>函数对整块内存投毒，并且将这块内存放入临时隔离队列(quarantine queue)，这样一段时间内这块内存不会再被malloc返回。</p></li></ol><h1 id="5-stack相关的bug发现"><a href="#5-stack相关的bug发现" class="headerlink" title="5. stack相关的bug发现"></a>5. stack相关的bug发现</h1><h2 id="5-1-stack-buffer-overflow"><a href="#5-1-stack-buffer-overflow" class="headerlink" title="5.1 stack-buffer-overflow"></a>5.1 stack-buffer-overflow</h2><p>定义栈上buffer时在它的周围插入redzones并poison，函数返回时unpoison。</p><h2 id="5-2-stack-use-after-return"><a href="#5-2-stack-use-after-return" class="headerlink" title="5.2 stack-use-after-return"></a>5.2 stack-use-after-return</h2><p>发现stack-use-after-return错误需分配fake stack以将stack转换为heap，因此它的算法原理类似于发现heap-use-after-free。</p><h2 id="5-3-stack-use-after-scope"><a href="#5-3-stack-use-after-scope" class="headerlink" title="5.3 stack-use-after-scope"></a>5.3 stack-use-after-scope</h2><p>在定义本地变量时unpoison它的内存，在定义所在的scope的尾部poison它的内存。</p><h1 id="6-未对齐的内存访问"><a href="#6-未对齐的内存访问" class="headerlink" title="6. 未对齐的内存访问"></a>6. 未对齐的内存访问</h1><p>当前的内存映射实现不会发现未对齐的部分越界访问，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *x = new int[2]; // 8 bytes: [0,7].</span><br><span class="line">int *u = (int*)((char*)x + 6);</span><br><span class="line">*u = 1;  // Access to range [6-9]</span><br></pre></td></tr></table></figure><h1 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h1><ul><li><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</a></p></li><li><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn">https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn</a></p></li><li><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterScope">https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterScope</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> sanitizer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c++ </tag>
            
            <tag> sanitizer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>破阵子·四十年来家国</title>
      <link href="/2024/09/22/%E7%A0%B4%E9%98%B5%E5%AD%90%E5%9B%9B%E5%8D%81%E5%B9%B4%E6%9D%A5%E5%AE%B6%E5%9B%BD/"/>
      <url>/2024/09/22/%E7%A0%B4%E9%98%B5%E5%AD%90%E5%9B%9B%E5%8D%81%E5%B9%B4%E6%9D%A5%E5%AE%B6%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">破阵子·四十年来家国</p></h1><h3><p style="text-align: center;">[五代] 李煜</p></h3><h3><p style="text-align: center;">四十年来家国，三千里地山河。凤阁龙楼连霄汉，玉树琼枝作烟萝，几曾识干戈？</p></h3><h3><p style="text-align: center;">一旦归为臣虏，沈腰潘鬓消磨。最是仓皇辞庙日，教坊犹奏别离歌，垂泪对宫娥。</p></h3>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自题金山画像</title>
      <link href="/2024/09/01/%E8%87%AA%E9%A2%98%E9%87%91%E5%B1%B1%E7%94%BB%E5%83%8F/"/>
      <url>/2024/09/01/%E8%87%AA%E9%A2%98%E9%87%91%E5%B1%B1%E7%94%BB%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">自题金山画像</p></h1><h3><p style="text-align: center;">[宋] 苏轼</p></h3><h2><p style="text-align: center;">心似已灰之木，身如不系之舟。</p></h2><h2><p style="text-align: center;">问汝平生功业，黄州惠州儋州。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少年行</title>
      <link href="/2024/08/20/%E5%B0%91%E5%B9%B4%E8%A1%8C/"/>
      <url>/2024/08/20/%E5%B0%91%E5%B9%B4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">少年行</p></h1><h3><p style="text-align: center;">[唐] 王维</p></h3><h3><p style="text-align: center;">（其一）</p></h3><h2><p style="text-align: center;">新丰美酒斗十千，咸阳游侠多少年。</p></h2><h2><p style="text-align: center;">相逢意气为君饮，系马高楼垂柳边。</p></h2><h3><p style="text-align: center;">（其二）</p></h3><h2><p style="text-align: center;">出身仕汉羽林郎，初随骠骑战渔阳。</p></h2><h2><p style="text-align: center;">孰知不向边庭苦，纵死犹闻侠骨香。</p></h2><h3><p style="text-align: center;">（其三）</p></h3><h2><p style="text-align: center;">一身能擘两雕弧，虏骑千重只似无。</p></h2><h2><p style="text-align: center;">偏坐金鞍调白羽，纷纷射杀五单于。</p></h2><h3><p style="text-align: center;">（其四）</p></h3><h2><p style="text-align: center;">汉家君臣欢宴终，高议云台论战功。</p></h2><h2><p style="text-align: center;">天子临轩赐侯印，将军佩出明光宫。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唐太宗封禅与魏征答问</title>
      <link href="/2024/08/17/%E5%94%90%E5%A4%AA%E5%AE%97%E5%B0%81%E7%A6%85%E4%B8%8E%E9%AD%8F%E5%BE%81%E7%AD%94%E9%97%AE/"/>
      <url>/2024/08/17/%E5%94%90%E5%A4%AA%E5%AE%97%E5%B0%81%E7%A6%85%E4%B8%8E%E9%AD%8F%E5%BE%81%E7%AD%94%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1>出自《资治通鉴·唐纪·唐纪十》</h1><p>上曰：“公不欲朕封禅者，以功未高邪？”<br>曰：“高矣。”<br>“德未厚邪？”<br>曰：“厚矣。”<br>“中国未安邪？”<br>曰：“安矣。”<br>“四夷未服邪？”<br>曰：“服矣。”<br>“年谷未丰邪？”<br>曰：“丰矣。”<br>“符瑞未至邪？”<br>曰：“至矣。”<br>“然则何为不可封禅？”<br>对曰：“陛下虽有此六者，然承隋末大乱之后，户口未复，仓廪尚虚，而车驾东巡，千乘万骑，其供顿劳费，未易任也。且陛下封禅，则万国咸集，远夷君长，皆当扈从；今自伊、洛以东至于海、岱，烟火尚希，灌莽极目，此乃引戎狄入腹中，示之以虚弱也。况赏赉不赀，未厌远人之望；给复连年，不偿百姓之劳；<b>崇虚名而受实害</b>，陛下将焉用之！”</p>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> excerpt(摘抄) </tag>
            
            <tag> history(历史) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南乡子·登京口北固亭有怀</title>
      <link href="/2024/08/07/%E5%8D%97%E4%B9%A1%E5%AD%90%E7%99%BB%E4%BA%AC%E5%8F%A3%E5%8C%97%E5%9B%BA%E4%BA%AD%E6%9C%89%E6%80%80/"/>
      <url>/2024/08/07/%E5%8D%97%E4%B9%A1%E5%AD%90%E7%99%BB%E4%BA%AC%E5%8F%A3%E5%8C%97%E5%9B%BA%E4%BA%AD%E6%9C%89%E6%80%80/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">南乡子·登京口北固亭有怀</p></h1><h3><p style="text-align: center;">[宋] 辛弃疾</p></h3><h3><p style="text-align: center;">何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。</p></h3><h3><p style="text-align: center;">年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。</p></h3>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一月四日风雨大作二首</title>
      <link href="/2024/07/20/%E5%8D%81%E4%B8%80%E6%9C%88%E5%9B%9B%E6%97%A5%E9%A3%8E%E9%9B%A8%E5%A4%A7%E4%BD%9C%E4%BA%8C%E9%A6%96/"/>
      <url>/2024/07/20/%E5%8D%81%E4%B8%80%E6%9C%88%E5%9B%9B%E6%97%A5%E9%A3%8E%E9%9B%A8%E5%A4%A7%E4%BD%9C%E4%BA%8C%E9%A6%96/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">十一月四日风雨大作二首</p></h1><h3><p style="text-align: center;">[宋] 陆游</p></h3><h1><p style="text-align: center;">（其一）</p></h1><h2><p style="text-align: center;">风卷江湖雨暗村，四山声作海涛翻。</p></h2><h2><p style="text-align: center;">溪柴火软蛮毡暖，我与狸奴不出门。</p></h2><h1><p style="text-align: center;">（其二）</p></h1><h2><p style="text-align: center;">僵卧孤村不自哀，尚思为国戍轮台。</p></h2><h2><p style="text-align: center;">夜阑卧听风吹雨，铁马冰河入梦来。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虞美人·听雨</title>
      <link href="/2024/07/10/%E8%99%9E%E7%BE%8E%E4%BA%BA%E5%90%AC%E9%9B%A8/"/>
      <url>/2024/07/10/%E8%99%9E%E7%BE%8E%E4%BA%BA%E5%90%AC%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">虞美人·听雨</p></h1><h3><p style="text-align: center;">[宋] 蒋捷</p></h3><h3><p style="text-align: center;">少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低、断雁叫西风。</p></h3><h3><p style="text-align: center;">而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前、点滴到天明。</p></h3>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash job control</title>
      <link href="/2024/06/03/linux-bash-job-control/"/>
      <url>/2024/06/03/linux-bash-job-control/</url>
      
        <content type="html"><![CDATA[<h1 id="1-job-control是什么"><a href="#1-job-control是什么" class="headerlink" title="1. job control是什么"></a>1. job control是什么</h1><p>job control指<strong>暂停执行进程</strong>并稍后<strong>继续执行</strong>它的能力。</p><p>bash给每个pipeline关联一个job。</p><h1 id="2-前台进程和后台进程"><a href="#2-前台进程和后台进程" class="headerlink" title="2. 前台进程和后台进程"></a>2. 前台进程和后台进程</h1><p>前台(foreground)进程指，与当前终端进程的进程组id(process group id)相同的进程； 反之为后台(background)进程。</p><p>区别包括：</p><ol><li><p>前台进程接受<strong>键盘生成的信号</strong>(如ctrl+c生成SIGINT)，后台进程不会接受。</p></li><li><p>只有前台进程被允许<strong>读取终端</strong>，后台进程如果尝试读终端会被发送SIGTTIN信号，它会暂停(suspend)该进程。</p></li></ol><h1 id="3-job-spec"><a href="#3-job-spec" class="headerlink" title="3. job spec"></a>3. job spec</h1><ol><li><p><code>%&lt;n&gt;</code>指第n个job</p></li><li><p><code>%</code>和<code>%%</code>和<code>%+</code>指当前job(即最后一个从foreground暂停或从background启动的job)</p></li><li><p><code>%-</code>指前一个job</p></li></ol><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h1><h2 id="4-1-Ctrl-Z-suspend字符"><a href="#4-1-Ctrl-Z-suspend字符" class="headerlink" title="4.1 Ctrl+Z(suspend字符)"></a>4.1 <code>Ctrl+Z</code>(suspend字符)</h2><p>暂停进程，同时控制权返回给bash。</p><h2 id="4-2-Ctrl-Y-delayed-suspend字符"><a href="#4-2-Ctrl-Y-delayed-suspend字符" class="headerlink" title="4.2 Ctrl+Y(delayed suspend字符)"></a>4.2 <code>Ctrl+Y</code>(delayed suspend字符)</h2><p>在进程尝试<strong>读终端</strong>时，暂停进程并把控制权返回给bash。</p><h2 id="4-3-bg命令"><a href="#4-3-bg命令" class="headerlink" title="4.3 bg命令"></a>4.3 <code>bg</code>命令</h2><p>用法为<code>bg [&lt;jobspec&gt;...]</code></p><p>使指定的job在后台恢复执行(仿佛它们启动时在命令行加了<code>&amp;</code>)。</p><p>如果不指定jobspec，使用当前job。</p><p>使用<code>&lt;jobspec&gt; &amp;</code>也一样。</p><h2 id="4-4-fg命令"><a href="#4-4-fg命令" class="headerlink" title="4.4 fg命令"></a>4.4 <code>fg</code>命令</h2><p>用法为<code>fg [&lt;jobspec&gt;]</code></p><p>使指定的job在前台恢复执行，它也成为<strong>当前job</strong>。</p><p>如果不指定jobspec，使用当前job。</p><p>仅使用<code>&lt;jobspec&gt;</code>不加fg也一样。</p><h2 id="4-5-jobs命令"><a href="#4-5-jobs命令" class="headerlink" title="4.5 jobs命令"></a>4.5 <code>jobs</code>命令</h2><p>用法为<code>jobs [-lrs] [&lt;jobspec&gt;]</code></p><p>用于列举jobs。带<code>&lt;jobspec&gt;</code>则只列举它，否则列举所有jobs。</p><p>标记<code>+</code>的为当前job，标记<code>-</code>的为前一个job。</p><ul><li><p><code>-l</code> 同时列出进程ID</p></li><li><p><code>-r</code> 只列出running的jobs</p></li><li><p><code>-s</code> 只列出stopped的jobs</p></li></ul><h2 id="4-6-kill命令"><a href="#4-6-kill命令" class="headerlink" title="4.6 kill命令"></a>4.6 <code>kill</code>命令</h2><p>用法为<code>kill [-sigspec] &lt;jobspec&gt;|&lt;pid&gt;</code></p><p>给<code>&lt;jobspec&gt;</code>或者<code>&lt;pid&gt;</code>标识的进程发送信号<code>sigspec</code>。</p><p>如果<code>-sigspec</code>未指定则默认发送<code>SIGTERM</code>。</p><p><code>kill -l|-L</code>可列出信号名和数字的对应关系。</p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git stash命令用法</title>
      <link href="/2024/05/09/git-stash/"/>
      <url>/2024/05/09/git-stash/</url>
      
        <content type="html"><![CDATA[<h1 id="1-stash特定文件"><a href="#1-stash特定文件" class="headerlink" title="1. stash特定文件"></a>1. stash特定文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash push [-m message] &lt;path&gt;...</span><br></pre></td></tr></table></figure><h1 id="2-展示stash内容"><a href="#2-展示stash内容" class="headerlink" title="2. 展示stash内容"></a>2. 展示stash内容</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash show [-p] &lt;index&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;index&gt;</code>为stash索引号数字，不带<code>-p</code>选项只显示变动文件名，带上<code>-p</code>显示变动内容</p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux vim常用命令</title>
      <link href="/2024/05/08/linux-vim-command/"/>
      <url>/2024/05/08/linux-vim-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h1><h2 id="1-1-向后查找"><a href="#1-1-向后查找" class="headerlink" title="1.1 向后查找"></a>1.1 向后查找</h2><p>命令为<code>/&lt;search_word&gt;</code>然后回车，使用<code>n</code>定位到下一次出现，使用<code>N</code>定位到上一次出现</p><h2 id="1-2-向前查找"><a href="#1-2-向前查找" class="headerlink" title="1.2 向前查找"></a>1.2 向前查找</h2><p>使用命令<code>?&lt;search_word&gt;</code></p><h2 id="1-3-case-insensitive"><a href="#1-3-case-insensitive" class="headerlink" title="1.3 case-insensitive"></a>1.3 case-insensitive</h2><p>查找默认是case-sensitive的，若想insensitive，在<code>&lt;search_word&gt;</code>前或者后添加<code>\c</code></p><p>例如<code>/&lt;search_word&gt;\c</code></p><h1 id="2-替换"><a href="#2-替换" class="headerlink" title="2. 替换"></a>2. 替换</h1><h2 id="2-1-全文替换"><a href="#2-1-全文替换" class="headerlink" title="2.1 全文替换"></a>2.1 全文替换</h2><p>命令为<code>:%s/&lt;search_word&gt;/&lt;replace_word&gt;/g</code></p><p>将全文中所有的<code>&lt;search_word&gt;</code>替换为<code>&lt;replace_word&gt;</code>，这是case-sensitive的</p><p>若想case-insensitive，给上述命令添加<code>i</code>选项</p><h2 id="2-2-每次替换时询问"><a href="#2-2-每次替换时询问" class="headerlink" title="2.2 每次替换时询问"></a>2.2 每次替换时询问</h2><p>若想在每次替换实际发生时询问是否确认，给上述命令添加<code>c</code>选项(c表示confirmation)，即</p><p><code>:%s/&lt;search_word&gt;/&lt;replace_word&gt;/gc</code></p><p>在prompt出现时的回答包括：</p><ol><li><p><code>y</code>，表示yes，即这次替换</p></li><li><p><code>n</code>，表示no，即这次不替换</p></li><li><p><code>a</code>，表示all，即从此往后的出现都直接替换并使命令退出</p></li><li><p><code>q</code>，表示quit，这次不替换并使命令退出</p></li><li><p>以及其他</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git submodule命令用法</title>
      <link href="/2024/05/06/git-submodule/"/>
      <url>/2024/05/06/git-submodule/</url>
      
        <content type="html"><![CDATA[<h1 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h1><p>submodule指向子模块仓库一个特定的commit，也可以追踪子模块仓库一个特定的分支</p><h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><h2 id="2-1-添加子模块"><a href="#2-1-添加子模块" class="headerlink" title="2.1 添加子模块"></a>2.1 添加子模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add [-b branch] &lt;repository&gt; [&lt;path&gt;]</span><br></pre></td></tr></table></figure><p>添加<code>&lt;repository&gt;</code>的branch分支到<code>&lt;path&gt;</code>目录</p><h2 id="2-2-clone主仓库"><a href="#2-2-clone主仓库" class="headerlink" title="2.2 clone主仓库"></a>2.2 clone主仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive &lt;parent-repository&gt;</span><br></pre></td></tr></table></figure><p>在克隆主仓库时同时克隆其中包含的子模块</p><h2 id="2-3-下载主仓库的所有子模块内容"><a href="#2-3-下载主仓库的所有子模块内容" class="headerlink" title="2.3 下载主仓库的所有子模块内容"></a>2.3 下载主仓库的所有子模块内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h2 id="2-4-更新到子模块远程仓库的状态"><a href="#2-4-更新到子模块远程仓库的状态" class="headerlink" title="2.4 更新到子模块远程仓库的状态"></a>2.4 更新到子模块远程仓库的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><p>这个命令会改变submodule指向的子模块仓库中的具体commit</p><h2 id="2-5-修改submodule指向的commit"><a href="#2-5-修改submodule指向的commit" class="headerlink" title="2.5 修改submodule指向的commit"></a>2.5 修改submodule指向的commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;path-to-submodule&gt;</span><br><span class="line"></span><br><span class="line">git checkout &lt;some-commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> &lt;path-to-parent-repository&gt;</span><br><span class="line"></span><br><span class="line">git add &lt;path-to-submodule&gt;</span><br><span class="line"></span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>去子模块目录修改commit，然后在主仓库把这个更改commit即可</p><h2 id="2-6-删除子模块"><a href="#2-6-删除子模块" class="headerlink" title="2.6 删除子模块"></a>2.6 删除子模块</h2><p>使用下述三条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> &lt;path-to-submodule&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf .git/modules/&lt;path-to-submodule&gt;</span><br><span class="line"></span><br><span class="line">git config --remove-section submodule.&lt;path-to-submodule&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux sed命令使用方法</title>
      <link href="/2024/05/06/linux-sed-command/"/>
      <url>/2024/05/06/linux-sed-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-缩写"><a href="#1-缩写" class="headerlink" title="1. 缩写"></a>1. 缩写</h1><p><code>sed</code>是<code>stream editor</code>的缩写。</p><h1 id="2-常用选项"><a href="#2-常用选项" class="headerlink" title="2. 常用选项"></a>2. 常用选项</h1><ol><li><code>-i</code>，原地修改输入文件</li></ol><h1 id="3-常见使用场景"><a href="#3-常见使用场景" class="headerlink" title="3. 常见使用场景"></a>3. 常见使用场景</h1><h1 id="3-1-替换某个文本的所有出现"><a href="#3-1-替换某个文本的所有出现" class="headerlink" title="3.1 替换某个文本的所有出现"></a>3.1 替换某个文本的所有出现</h1><p>使用方法为<code>sed &#39;s/&lt;word1&gt;/&lt;word2&gt;/g&#39; input.txt</code></p><ol><li><p><code>s</code>指substitution(替换)</p></li><li><p><code>/</code>是分隔符，也可以是其他字符作分隔符，如<code>+</code></p></li><li><p><code>&lt;word1&gt;</code>是被替换的字符串</p></li><li><p><code>&lt;word2&gt;</code>是要替换为的字符串</p></li><li><p><code>g</code>表示global(全局替换)，不指定<code>g</code>的话只会替换每一行的第一次出现的<code>&lt;word1&gt;</code>。</p></li></ol><h1 id="3-2-删除指定行"><a href="#3-2-删除指定行" class="headerlink" title="3.2 删除指定行"></a>3.2 删除指定行</h1><p>行编号都是从1开始</p><ul><li><p><code>sed &#39;&lt;n&gt;d&#39; input.txt</code>，删除第<code>&lt;n&gt;</code>行</p></li><li><p><code>sed &#39;$d&#39; input.txt</code>，删除最后一行</p></li><li><p><code>sed &#39;&lt;start&gt;,&lt;end&gt;d&#39; input.txt</code>，删除第<code>&lt;start&gt;</code>到<code>&lt;end&gt;</code>行(闭区间)</p></li></ul><h1 id="4-sed的正则表达式"><a href="#4-sed的正则表达式" class="headerlink" title="4. sed的正则表达式"></a>4. <code>sed</code>的正则表达式</h1><p><code>sed</code>默认使用Basic Regular Expression(BRE)语法，如果指定了<code>-E</code>或者<code>-r</code>或者<code>--regexp-extended</code>选项则使用Extended Regular Expression(ERE)语法。</p><p>BRE和ERE的唯一区别在于这些特殊字符的行为：<code>?</code>, <code>+</code>, <code>(</code>, <code>)</code>,<code>&#123;</code>, <code>&#125;</code>,<code>|</code>。在BRE中它们直接使用就是普通字符，加上<code>\</code>前缀之后才是特殊的元字符；而在ERE中正好相反，直接使用是元字符，加上<code>\</code>前缀变成普通字符。</p><p>Basic Regular Expression(BRE)语法常用规则如下：</p><ol><li><p><code>&lt;char&gt;</code>，普通字符<code>&lt;char&gt;</code>匹配自身</p></li><li><p><code>*</code>，匹配0次或多次前面的项(单个普通字符，单个位于<code>\</code>后的特殊字符，单个<code>.</code>，单个grouped regexp，或者单个方括号表达式)</p></li><li><p><code>\+</code>，类似<code>*</code>，但匹配1次或多次</p></li><li><p><code>\?</code>，类似<code>*</code>，但匹配0次或1次</p></li><li><p><code>.</code>，匹配任意单个字符，包括newline</p></li><li><p><code>^</code>，表示行的开头</p></li><li><p><code>$</code>，表示行的结束</p></li><li><p><code>[&lt;list&gt;]</code>，匹配<code>&lt;list&gt;</code>中的任意单个字符，<code>&lt;list&gt;</code>也可以包括<code>char1-char2</code>用于指定其中的所有字符(闭区间)，<code>&lt;list&gt;</code>中也可以包括字符类(如<code>[:blank:]</code>表示空字符，即空格和tab)</p></li><li><p><code>[^&lt;list&gt;]</code>，类似<code>[&lt;list&gt;]</code>，但匹配不在<code>&lt;list&gt;</code>中的任意单个字符</p></li><li><p><code>\(&lt;regexp&gt;\)</code>，将<code>&lt;regexp&gt;</code>当做一个整体，构成一个grouped regexp(使用举例：整体应用<code>*</code>操作符等)</p></li><li><p><code>&lt;regexp1&gt;\|&lt;regexp2&gt;</code>，匹配<code>&lt;regexp1&gt;</code>或者<code>&lt;regexp2&gt;</code></p></li><li><p><code>&lt;regexp1&gt;&lt;regexp2&gt;</code>，匹配<code>&lt;regexp1&gt;</code>和<code>&lt;regexp2&gt;</code>的连接</p></li><li><p><code>\n</code>，匹配newline</p></li><li><p><code>\&lt;char&gt;</code>，匹配特殊字符<code>&lt;char&gt;</code>，<code>&lt;char&gt;</code>可以是<code>$</code>, <code>*</code>, <code>.</code>, <code>[</code>, <code>\</code>, <code>^</code></p></li></ol><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><ol><li><p><a href="https://www.gnu.org/software/sed/manual/html_node/index.html#Top">GNU sed文档</a></p></li><li><p><a href="https://www.gnu.org/software/sed/manual/html_node/sed-regular-expressions.html#sed-regular-expressions">GNU sed正则表达式</a></p></li><li><p><a href="https://www.gnu.org/software/sed/manual/html_node/BRE-syntax.html#BRE-syntax">GNU sed BRE语法</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux生成动态库</title>
      <link href="/2024/05/05/linux-generate-shared-lib/"/>
      <url>/2024/05/05/linux-generate-shared-lib/</url>
      
        <content type="html"><![CDATA[<h1 id="1-fPIC选项"><a href="#1-fPIC选项" class="headerlink" title="1. -fPIC选项"></a>1. <code>-fPIC</code>选项</h1><p>所有作为输入的目标文件和静态库在编译时必须添加了<code>-fPIC</code>选项，才能生成动态库。</p><h1 id="2-生成动态链接库"><a href="#2-生成动态链接库" class="headerlink" title="2. 生成动态链接库"></a>2. 生成动态链接库</h1><p>使用<code>g++</code>命令把多个静态库和目标文件生成动态库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wl,--whole-archive -l:&lt;libfirst.a&gt; -l:&lt;libsecond.a&gt; ...</span><br><span class="line">    -Wl,--no-whole-archive</span><br><span class="line">    -l:&lt;libthird.a&gt; ...</span><br><span class="line">    &lt;object_first.o&gt; &lt;object_second.o&gt; ...</span><br><span class="line">    -Wl,-L&lt;lib_path&gt;</span><br><span class="line">    -shared</span><br><span class="line">    -o &lt;libshared.so&gt;</span><br></pre></td></tr></table></figure><ol><li><p><code>-Wl,--whole-archive</code>后指定需要包括其中所有目标文件的库</p></li><li><p><code>-Wl,--no-whole-archive</code>用以取消<code>-Wl,--whole-archive</code>的后续作用</p></li><li><p><code>-Wl,-L&lt;lib_path&gt;</code>用以添加库文件查找目录</p></li><li><p><code>-shared</code>表明此次链接要创建一个动态库</p></li><li><p><code>-o &lt;libshared.so&gt;</code>指定要创建的动态库文件名</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> linker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> linker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux生成静态库</title>
      <link href="/2024/05/05/linux-generate-static-lib/"/>
      <url>/2024/05/05/linux-generate-static-lib/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用ar-M-merge-script-命令"><a href="#1-使用ar-M-merge-script-命令" class="headerlink" title="1. 使用ar -M [ &lt; merge.script ]命令"></a>1. 使用<code>ar -M [ &lt; merge.script ]</code>命令</h1><p>写一个脚本<code>merge.script</code>，将脚本重定向给<code>ar -M</code>命令的stdin。</p><p>使用<code>create</code>传入输出的静态库文件名，<code>addlib</code>传入输入的静态库，<code>addmod</code>传入输入的目标文件，最后调用<code>save</code>和<code>end</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create &lt;libmerged.a&gt;</span><br><span class="line">addlib &lt;libfirst.a&gt;</span><br><span class="line">addlib &lt;libsecond.a&gt;</span><br><span class="line">...</span><br><span class="line">addmod &lt;object_first.o&gt;</span><br><span class="line">addmod &lt;object_second.o&gt;</span><br><span class="line">...</span><br><span class="line">save</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="2-注意排列顺序"><a href="#2-注意排列顺序" class="headerlink" title="2. 注意排列顺序"></a>2. 注意排列顺序</h1><p>把必须包括其所有符号的输入库放在前面，因为在后面库中包含重复符号名的时候<strong>可能</strong>直接丢弃以前面为准。</p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h1><ul><li><p><a href="https://stackoverflow.com/a/23621751/18781047">stackoverflow</a></p></li><li><p><a href="https://sourceware.org/binutils/docs/binutils/ar-scripts.html">文档</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> linker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> linker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux nm命令常见用法</title>
      <link href="/2024/05/05/linux-nm-command/"/>
      <url>/2024/05/05/linux-nm-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-nm命令"><a href="#1-nm命令" class="headerlink" title="1. nm命令"></a>1. nm命令</h1><p>单词name的简称，用于查看二进制目标文件中的符号信息</p><h1 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h1><p>三列，分别是(1)符号地址(2)符号类型(3)符号名</p><p>常见符号类型包括(1)”T”，”t”，代码段中的符号(2)”U”(大写字母u)，未定义的符号</p><h1 id="3-常用选项"><a href="#3-常用选项" class="headerlink" title="3. 常用选项"></a>3. 常用选项</h1><h2 id="3-1-A"><a href="#3-1-A" class="headerlink" title="3.1 -A"></a>3.1 <code>-A</code></h2><p>在每一行都显示文件名</p><h2 id="3-2-C"><a href="#3-2-C" class="headerlink" title="3.2 -C"></a>3.2 <code>-C</code></h2><p>符号名demangle</p><h2 id="3-3-u，小写字母u"><a href="#3-3-u，小写字母u" class="headerlink" title="3.3 -u，小写字母u"></a>3.3 <code>-u</code>，小写字母u</h2><p>只显示未定义的符号</p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> linker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> linker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux ldd命令使用方法</title>
      <link href="/2024/05/05/linux-ldd-command/"/>
      <url>/2024/05/05/linux-ldd-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h1><p>打印可执行程序或者动态库的动态库依赖</p><h1 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h1><p>ldd是一个可执行shell脚本，其设置LD_TRACE_LOADED_OBJECTS环境变量为非空值，调用动态链接器ld.so</p><p>例如，为了查看ls命令的依赖，<code>ldd /usr/bin/ls</code></p><p>相当于</p><p><code>LD_TRACE_LOADED_OBJECTS=1 /lib64/ld-linux-x86-64.so.2 /usr/bin/ls</code></p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> linker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> linker </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux ld命令使用方法</title>
      <link href="/2024/05/05/linux-ld-command/"/>
      <url>/2024/05/05/linux-ld-command/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ld命令-linux链接器"><a href="#1-ld命令-linux链接器" class="headerlink" title="1. ld命令: linux链接器"></a>1. ld命令: linux链接器</h1><p>作用: 将一系列目标文件(.o)和静态库文件(.a)链接起来(动态库文件.so也可能作为ld的输入文件)</p><h1 id="2-常用选项"><a href="#2-常用选项" class="headerlink" title="2. 常用选项"></a>2. 常用选项</h1><p>注意：对于单字母的选项(如<code>-l</code>等)，选项的参数直接跟在选项之后，用不用空格分隔都可以。</p><h2 id="2-1-l-或者-library"><a href="#2-1-l-或者-library" class="headerlink" title="2.1 -l &lt;namespec&gt;或者--library=&lt;namespec&gt;"></a>2.1 <code>-l &lt;namespec&gt;</code>或者<code>--library=&lt;namespec&gt;</code></h2><p>使用<code>&lt;namespec&gt;</code>标识的库文件(动态库lib<namespec>.so优先于静态库lib<namespec>.a)。</p><p>如果<code>&lt;namespec&gt;</code>是<code>:filename</code>的形式，查找文件名为<code>filename</code>的库文件。</p><h2 id="2-2-L-或者-library-path"><a href="#2-2-L-或者-library-path" class="headerlink" title="2.2 -L &lt;searchdir&gt;或者--library-path=&lt;searchdir&gt;"></a>2.2 <code>-L &lt;searchdir&gt;</code>或者<code>--library-path=&lt;searchdir&gt;</code></h2><p>添加一个查找库文件(和控制脚本)的目录<code>&lt;searchdir&gt;</code>以供<code>-l</code>选项使用，多个此选项之间的顺序关系为在命令行出现的顺序，最后为默认查找目录。</p><p>默认查找目录是系统依赖的，较为复杂，如&#x2F;lib&#x2F;x86_64-linux-gnu。</p><h2 id="2-3-rpath"><a href="#2-3-rpath" class="headerlink" title="2.3 -rpath=&lt;dir&gt;"></a>2.3 <code>-rpath=&lt;dir&gt;</code></h2><p>添加<code>&lt;dir&gt;</code>到此次生成的动态库或可执行文件的运行时动态库查找路径，以供动态链接器使用。</p><h2 id="2-4-shared"><a href="#2-4-shared" class="headerlink" title="2.4 -shared"></a>2.4 <code>-shared</code></h2><p>表明此次链接要创建一个共享库。</p><h2 id="2-5-static"><a href="#2-5-static" class="headerlink" title="2.5 -static"></a>2.5 <code>-static</code></h2><p>与<code>-shared</code>不同，<code>-static</code>表示其之后的<code>-l</code>选项<strong>只选择静态库</strong>去参与链接。</p><h2 id="2-6-start-group-end-group"><a href="#2-6-start-group-end-group" class="headerlink" title="2.6 -( &lt;archives&gt; -) --start-group &lt;archives&gt; --end-group"></a>2.6 <code>-( &lt;archives&gt; -)</code> <code>--start-group &lt;archives&gt; --end-group</code></h2><p><code>&lt;archives&gt;</code>指定的库文件会被重复查找以解析未定义符号，而非按命令行出现顺序只查找一次，此选项可能会带来较大性能开销。</p><h2 id="2-7-whole-archive和-no-whole-archive"><a href="#2-7-whole-archive和-no-whole-archive" class="headerlink" title="2.7 --whole-archive和--no-whole-archive"></a>2.7 <code>--whole-archive</code>和<code>--no-whole-archive</code></h2><p><code>--whole-archive</code>之后的.a静态库中的所有目标文件都会被链接进来，而不是像普通情况下只链接其中用到的目标文件。</p><p>这个选项常被用来将静态库转为动态库。</p><p>使用<code>--whole-archive</code>后不要忘记使用<code>--no-whole-archive</code>取消后续作用。</p><h2 id="2-8-version-script"><a href="#2-8-version-script" class="headerlink" title="2.8 --version-script=&lt;version-scriptfile&gt;"></a>2.8 <code>--version-script=&lt;version-scriptfile&gt;</code></h2><p>指定version script，常常在创建共享库时使用。可以用来做共享库的符号隐藏，脚本文件内容示例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  global:</span><br><span class="line">    extern &quot;C++&quot; &#123;</span><br><span class="line">        my_namespace::*;</span><br><span class="line">        my_prefix_*;</span><br><span class="line">    &#125;;</span><br><span class="line">  local: *;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述文件中标记为global的符号会被导出，其他标记为local的符号不可见。</p><p>关于共享库的符号导出，GNU有<a href="https://www.gnu.org/software/gnulib/manual/html_node/Exported-Symbols-of-Shared-Libraries.html" title="Controlling the Exported Symbols of Shared Libraries">文章</a>介绍。</p><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><ol><li><p>被链接为动态库的目标文件需要在编译时指定<code>-fPIC</code>选项，在x86平台上<code>-fPIC</code>(大写字母)和<code>-fpic</code>(小写字母)没有区别</p></li><li><p>静态库.a只是一些目标文件.o的集合外加一些索引信息; 从ld的视角，静态库像一个“半成品”，动态库是“最终产品(final product)”，因为不能merge两个动态库成一个动态库，但静态库可以任意merge为新的静态库或者动态库</p></li><li><p>当使用编译器驱动器去调用ld时，传递给ld的命令行选项应该使用前缀<code>-Wl,</code></p></li><li><p>使用编译器驱动器(compiler driver, 如gcc或者g++)去调用ld，尽量不要直接调用，否则可能有未指定到的选项</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> linker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> linker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux加载器、加载、动态链接器与动态链接</title>
      <link href="/2024/05/05/linux-loader-loading-linker-linking/"/>
      <url>/2024/05/05/linux-loader-loading-linker-linking/</url>
      
        <content type="html"><![CDATA[<h1 id="1-别名和对应的文件"><a href="#1-别名和对应的文件" class="headerlink" title="1. 别名和对应的文件"></a>1. 别名和对应的文件</h1><p>别名包括:</p><p>动态链接器(dynamic linker)，加载器(loader)，动态加载器(dynamic loader)，运行时链接器(run-time linker)，ELF解释器(ELF interpreter)，ld.so，ld-linux.so</p><p>上述这些描述的是同一件事，其对应的文件为:</p><p>ld.so，ld-linux.so，&#x2F;lib&#x2F;ld-linux.so.1，&#x2F;lib&#x2F;ld-linux.so.2，&#x2F;lib64&#x2F;ld-linux-x86-64.so.2</p><p>在现代linux机器上，一般使用的是&#x2F;lib&#x2F;ld-linux.so.2和&#x2F;lib64&#x2F;ld-linux-x86-64.so.2，用于处理ELF格式二进制文件</p><h1 id="2-动态链接器运行方式"><a href="#2-动态链接器运行方式" class="headerlink" title="2. 动态链接器运行方式"></a>2. 动态链接器运行方式</h1><ol><li><p>间接运行: 通过运行一个动态链接的程序或者共享库，ELF文件会将动态链接器存放在.interp段中</p></li><li><p>直接运行: &#x2F;lib&#x2F;ld-linux.so.*  [OPTIONS] [PROGRAM [ARGUMENTS]]</p></li></ol><h1 id="3-动态链接器作用"><a href="#3-动态链接器作用" class="headerlink" title="3. 动态链接器作用"></a>3. 动态链接器作用</h1><p>三步，(1)解析并加载程序所需的共享库依赖，(2)准备运行程序，(3)运行程序</p><h1 id="4-动态链接器解析动态库依赖的过程"><a href="#4-动态链接器解析动态库依赖的过程" class="headerlink" title="4. 动态链接器解析动态库依赖的过程"></a>4. 动态链接器解析动态库依赖的过程</h1><ol><li><p>检查每个依赖名(dependency string)是否包含字符<code>/</code></p><p> 1.1 如果包含，将此依赖名当做相对路径名或者绝对路径名使用</p><p> 1.2 如果不包含，转入第2步</p></li><li><p>依次在以下位置寻找依赖</p><p> 2.1 DT_RPATH(deprecated)</p><p> 2.2 环境变量<strong>LD_LIBRARY_PATH</strong>指定的目录，此变量中以冒号或者分号分隔目录，空目录名表示当前工作目录</p><p> 2.3 二进制文件的DT_RUNPATH属性</p><p> 2.4 &#x2F;etc&#x2F;ld.so.cache</p><p> 2.5 &#x2F;lib，&#x2F;usr&#x2F;lib，&#x2F;lib64，&#x2F;usr&#x2F;lib64 (还可能包括&#x2F;lib&#x2F;x86_64-linux-gnu)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> linker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> linker </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB反向执行</title>
      <link href="/2024/05/02/linux-gdb-reverse-execution/"/>
      <url>/2024/05/02/linux-gdb-reverse-execution/</url>
      
        <content type="html"><![CDATA[<h1 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h1><p>反向执行(Reverse Execution)应用在：当发现执行太过了的时候，关注的问题可能已经发生了，需要反向执行。</p><p>需要目标环境支持，不是所有目标环境都可以实现反向执行的。</p><h1 id="2-程序执行的记录-record-和重放-replay"><a href="#2-程序执行的记录-record-和重放-replay" class="headerlink" title="2. 程序执行的记录(record)和重放(replay)"></a>2. 程序执行的记录(record)和重放(replay)</h1><p>record会拖慢程序执行速度。</p><p>如果执行日志中包括下一条指令的执行记录，GDB会使用replay mode，此时运行程序不会真正执行代码，而是从执行日志中恢复程序状态。</p><p>否则如果执行日志中不包括下一条指令的执行记录，GDB会使用record mode，此时运行程序会正常执行，但GDB会记录执行日志以备将来replay。</p><p>即使程序运行的平台不支持Reverse Execution，在执行日志记录的范围内，GDB也可以通过replay支持Reverse Execution。</p><p>在反向执行时，如果执行日志包括先前指令的记录，GDB会使用replay mode，否则，如果平台支持反向执行，GDB会使用record mode，如果不支持则stop。</p><h1 id="3-record和replay相关的命令"><a href="#3-record和replay相关的命令" class="headerlink" title="3. record和replay相关的命令"></a>3. record和replay相关的命令</h1><h2 id="3-1-record-METHOD"><a href="#3-1-record-METHOD" class="headerlink" title="3.1 record [METHOD]"></a>3.1 <code>record [METHOD]</code></h2><p>缩写为<code>rec [METHOD]</code>。</p><p>启动process record and replay target。<code>record</code>命令需要在调用<code>run</code>或者<code>start</code>之后调用。<code>METHOD</code>参数可能的取值为：</p><ol><li><p><code>full</code>。默认值；由GDB软件实现；支持反向执行；不支持Non-Stop Mode。</p></li><li><p><code>btrace &lt;format&gt;</code>。依赖硬件支持；允许有限的反向执行。</p></li></ol><h2 id="3-2-record-stop"><a href="#3-2-record-stop" class="headerlink" title="3.2 record stop"></a>3.2 <code>record stop</code></h2><p>缩写为<code>rec s</code>。</p><p>停止process record and replay target，执行日志将被删除，进程或者终止或者保持在最后状态。</p><p>进程退出时该target会自动stop，重新调试需要再调<code>record</code>命令启动target。</p><h2 id="3-3-info-record"><a href="#3-3-info-record" class="headerlink" title="3.3 info record"></a>3.3 <code>info record</code></h2><p>缩写为<code>i rec</code>，展示记录的各种信息。</p><p>对于<code>METHOD</code>为<code>full</code>时，展示信息包括：</p><ol><li><p>当前处于record mode还是replay mode；</p></li><li><p>记录的最小和最大的指令号；</p></li><li><p>执行日志包含的指令数量；</p></li><li><p>等等。</p></li></ol><h2 id="3-4-record-delete"><a href="#3-4-record-delete" class="headerlink" title="3.4 record delete"></a>3.4 <code>record delete</code></h2><p>缩写为<code>rec d</code>。</p><p>在replay mode起作用，删除后续的执行日志并从当前开始记录新的执行日志，即抛弃过去记录的旧未来，开始创建并记录一个新未来。</p><h1 id="4-反向执行相关的命令"><a href="#4-反向执行相关的命令" class="headerlink" title="4. 反向执行相关的命令"></a>4. 反向执行相关的命令</h1><h2 id="4-1-reverse-continue-ignore-count"><a href="#4-1-reverse-continue-ignore-count" class="headerlink" title="4.1 reverse-continue [ignore-count]"></a>4.1 <code>reverse-continue [ignore-count]</code></h2><p>缩写为<code>rc [ignore-count]</code>，反向continue。</p><p>类似continue，遇到断点会停下来。</p><h2 id="4-2-reverse-step-count"><a href="#4-2-reverse-step-count" class="headerlink" title="4.2 reverse-step [count]"></a>4.2 <code>reverse-step [count]</code></h2><p>缩写为<code>rs [count]</code>，反向step。</p><p>类似step，上一行是函数调用的话会进入函数并stop在最后一条语句处。</p><h2 id="4-3-reverse-next-count"><a href="#4-3-reverse-next-count" class="headerlink" title="4.3 reverse-next [count]"></a>4.3 <code>reverse-next [count]</code></h2><p>缩写为<code>rn [count]</code>，反向next。</p><p>类似next，如果当前已经在某函数第一行会导致回到它的caller。</p><h2 id="4-4-reverse-finish"><a href="#4-4-reverse-finish" class="headerlink" title="4.4 reverse-finish"></a>4.4 <code>reverse-finish</code></h2><p>无缩写，反向执行直到当前函数的开始处，就像finish会执行到当前函数的结束处。</p><h2 id="4-5-set-exec-direction-reverse-forward"><a href="#4-5-set-exec-direction-reverse-forward" class="headerlink" title="4.5 set exec-direction [ reverse | forward ]"></a>4.5 <code>set exec-direction [ reverse | forward ]</code></h2><p>设置命令执行方向，受影响的命令包括<code>step</code>，<code>stepi</code>，<code>next</code>，<code>nexti</code>，<code>continue</code>，<code>finish</code>。注意<code>return</code>命令不能反向工作。</p><ol><li><p><code>forward</code>是默认值，正常向前执行。</p></li><li><p><code>reverse</code>时上述受影响命令会自动反向执行。</p></li></ol><h1 id="5-启用record和反向执行"><a href="#5-启用record和反向执行" class="headerlink" title="5. 启用record和反向执行"></a>5. 启用record和反向执行</h1><p>在启用AVX(Advanced Vector Extension)的现代CPU上<code>record</code>命令不能使用，glibc的string相关函数(<code>strlen</code>，<code>memset</code>等等)会使用AVX优化的版本，一般而言，要想使用GDB的反向执行，可能需要重新编译glibc或者修改动态链接器使它不要使用AVX版本的函数。</p><p>但是最近版本的glibc增加了tunables的功能可以容易地避开AVX，使用环境变量<code>GLIBC_TUNABLES=glibc.cpu.hwcaps=-AVX2</code>来调用GDB，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLIBC_TUNABLES=glibc.cpu.hwcaps=-AVX2 gdb ./my_program</span><br></pre></td></tr></table></figure><p>进入GDB后先调用<code>start</code>，再调用<code>record</code>，然后开始调试即可。</p><p>也可以在shell中配置一下gdb命令别名自动完成上述工作，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> rgdb=<span class="string">&#x27;GLIBC_TUNABLES=glibc.cpu.hwcaps=-AVX2 gdb -q -ex start -ex record&#x27;</span></span><br></pre></td></tr></table></figure><p>接着只需简单调用<code>rgdb</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgdb ./my_program</span><br></pre></td></tr></table></figure><h1 id="6-GDB的一个小bug"><a href="#6-GDB的一个小bug" class="headerlink" title="6. GDB的一个小bug"></a>6. GDB的一个小bug</h1><p>启用record后，在被调试进程运行完毕时，GDB提示是否真地退出程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The next instruction is syscall exit_group.  It will make the program exit.  Do you want to stop the program?([y] or n)</span><br></pre></td></tr></table></figure><p>但是输入<code>n</code>(即no)才会退出。</p><h1 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h1><ol><li><p>GDB文档</p><ol><li><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Reverse-Execution.html#Reverse-Execution">Running programs backward</a></p></li><li><p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Process-Record-and-Replay.html#Process-Record-and-Replay">Recording Inferior’s Execution and Replaying It</a></p></li></ol></li><li><p><a href="https://stackoverflow.com/a/61048314/18781047">stackoverflow</a></p></li><li><p><a href="https://gotplt.org/posts/the-story-of-tunables.html">GDB tunables</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB Watchpoint</title>
      <link href="/2024/05/02/linux-gdb-watchpoint/"/>
      <url>/2024/05/02/linux-gdb-watchpoint/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><p>watchpoint又称data breakpoint，用于监控某个表达式，当它的值改变时stop程序。</p><p>表达式可以是单个变量，也可以包含操作符(任意原语言中有效的操作符)。</p><h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h1><h1 id="2-1-software-watchpoint"><a href="#2-1-software-watchpoint" class="headerlink" title="2.1 software watchpoint"></a>2.1 software watchpoint</h1><p>GDB单步执行程序，然后每次都计算表达式值。因此程序执行速度可能慢了数百倍，而且它在被监控值改变后的下一条语句处才报告值改变，而非在确切的CPU指令处。</p><h1 id="2-2-hardware-watchpoint"><a href="#2-2-hardware-watchpoint" class="headerlink" title="2.2 hardware watchpoint"></a>2.2 hardware watchpoint</h1><p>依赖硬件支持(如x86架构)，不会减慢程序执行速度，且在改变被监控值的CPU指令执行时即能及时报告。</p><p>GDB会尽可能创建hardware watchpoint。</p><p>有时GDB不能创建hardware watchpoint，可能的原因包括：</p><ol><li><p>要监控的内存区域过大。(此时GDB可能把它拆分成多个小的hardware watchpoint)。</p></li><li><p>已经设置了太多hardware watchpoint。但可能到程序resume执行时(而不是创建watchpoint时)GDB才会报告”Hardware watchpoint <num>: Could not insert watchpoint”，此时需要delete或者disable一些hardware watchpoint。</p></li></ol><h1 id="3-创建watchpoint"><a href="#3-创建watchpoint" class="headerlink" title="3. 创建watchpoint"></a>3. 创建watchpoint</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch [-l|-location] expr [thread thread-id]</span><br></pre></td></tr></table></figure><p>为表达式<code>expr</code>创建监控，当它的值改变时stop程序。</p><p><code>-location</code>表明：<code>expr</code>计算的结果需要是一个左值，GDB会取它的地址并监控这个地址上的内容变化，它的类型决定了监控的内存大小。(如果<code>expr</code>本身是一个左值，有无<code>-location</code>都一样；如果<code>expr</code>是右值，带<code>-location</code>会报错，因为它不能取地址)</p><p><code>thread thread-id</code>表明：只有特定的线程<code>thread-id</code>改变<code>expr</code>的值，程序才会stop。这种限制线程的watchpoint只适用于hardware watchpoint。</p><h1 id="4-查看watchpoint"><a href="#4-查看watchpoint" class="headerlink" title="4. 查看watchpoint"></a>4. 查看watchpoint</h1><ul><li><p><code>info breakpoints</code>或者缩写为<code>i b</code>，展示所有断点，包括watchpoint</p></li><li><p><code>info watchpoints</code>，展示所有watchpoint</p></li></ul><h1 id="5-删除watchpoint"><a href="#5-删除watchpoint" class="headerlink" title="5. 删除watchpoint"></a>5. 删除watchpoint</h1><h2 id="5-1-主动删除"><a href="#5-1-主动删除" class="headerlink" title="5.1 主动删除"></a>5.1 主动删除</h2><ul><li><code>delete [BREAK_NUM]</code>或者缩写为<code>d [BREAK_NUM]</code></li></ul><h2 id="5-2-自动删除"><a href="#5-2-自动删除" class="headerlink" title="5.2 自动删除"></a>5.2 自动删除</h2><p>当本地变量<code>local_var</code>离开作用域时，含有<code>local_var</code>的<code>expr</code>的watchpoint都会被自动删除。</p><h1 id="6-多线程程序中的watchpoint"><a href="#6-多线程程序中的watchpoint" class="headerlink" title="6. 多线程程序中的watchpoint"></a>6. 多线程程序中的watchpoint</h1><p>按理说，GDB应该发现来自每个线程的对<code>expr</code>(被监控表达式)的改变。</p><p>对hardware watchpoint来说，GDB确实可以发现来自所有线程的修改。</p><p>对software watchpoint来说，GDB只能监控单线程中的<code>expr</code>。如果你自信<code>expr</code>只能被当前线程修改且不会发生线程切换，然后可以照常使用software watchpoint。然而，GDB可能不会注意到对<code>expr</code>的来自非当前线程的修改。</p><p>即：在多线程程序中，software watchpoint的作用有限。</p><h1 id="7-监控复杂类对象"><a href="#7-监控复杂类对象" class="headerlink" title="7. 监控复杂类对象"></a>7. 监控复杂类对象</h1><p>应该还是要先知道它的数据成员，拆成基本数据类型来监控。例如监控<code>std::string</code>类型的字符串变量<code>s</code>的内容变化，需要先拿到<code>s</code>的<code>char*</code>指针成员再监控该指针指向的内存，直接<code>watch s</code>(也可以但)不准确。</p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB 多线程调试</title>
      <link href="/2024/05/02/linux-gdb-multi-threaded/"/>
      <url>/2024/05/02/linux-gdb-multi-threaded/</url>
      
        <content type="html"><![CDATA[<h1 id="1-All-Stop-Mode"><a href="#1-All-Stop-Mode" class="headerlink" title="1. All-Stop Mode"></a>1. All-Stop Mode</h1><p>这是GDB的默认模式(共两个模式，另一个为Non-Stop Mode)。</p><p>当一个线程stop时(比如因为hit断点)，所有线程都stop。</p><p>类似地，当继续执行这个线程时(比如使用<code>step</code>或者<code>next</code>命令)，所有其他线程也会恢复执行，但它们不受当前线程的<code>step</code>或者<code>next</code>命令控制而自由执行(因为线程调度依赖kernel，而不受GDB控制)，因此可能执行任意条语句。而且当这些其他线程遇到断点时会导致GDB发生自动线程切换，此时原线程的<code>step</code>或者<code>next</code>命令甚至可能还没执行完。</p><h2 id="1-1-锁住OS-scheduler"><a href="#1-1-锁住OS-scheduler" class="headerlink" title="1.1 锁住OS scheduler"></a>1.1 锁住OS scheduler</h2><p>这是为了在恢复执行时只允许一个线程运行。</p><p>scheduler锁定模式有多种，使用命令<code>set scheduler-locking &lt;mode&gt;</code>设置，<code>show scheduler-locking</code>获取。</p><p>可用的模式有：</p><ul><li><p><code>off</code> 无锁定，任意线程可以任意运行。</p></li><li><p><code>on</code> 只有当前线程可以运行，其他线程依然stop。</p></li><li><p><code>step</code> 当单步执行时效果类似<code>on</code>，使用其他执行命令(如<code>continue</code>, <code>until</code>, <code>finish</code>)时类似<code>off</code>。(由于机器不支持此模式，未测试文档中的”单步执行”是不是指<code>step</code>和<code>next</code>命令)</p></li><li><p><code>replay</code> (默认模式)在replay模式时类似于<code>on</code>，在record模式和正常执行时类似<code>off</code>。</p></li></ul><h1 id="2-libthread-db"><a href="#2-libthread-db" class="headerlink" title="2. libthread_db"></a>2. libthread_db</h1><p>GDB使用libthread_db库(字母db指debug)来进行线程调试，它会自动查找和libpthread库相匹配的libthread_db库并初始化，如果不能找到libthread_db，线程调试会被disable。</p><p>在使用<code>start</code>或者<code>run</code>命令启动程序时，GDB会打印libthread_db的信息。</p><p>即便程序只有一个主线程，GDB依然使用libthread_db来enable线程调试。</p><h1 id="3-相关命令"><a href="#3-相关命令" class="headerlink" title="3. 相关命令"></a>3. 相关命令</h1><ul><li><p><code>p $_thread</code>，打印当前线程号。</p></li><li><p><code>info threads [thread-id-list]</code>或者缩写为<code>i th [ids]</code>，查看所有线程或指定的线程。</p></li><li><p><code>thread [THREAD_NUM]</code>或者缩写为<code>t [THREAD_NUM]</code>，切换线程。</p></li><li><p><code>thread name [NAME]</code>，给当前线程设置名字，空的<code>NAME</code>会删除已存在的名字。</p></li><li><p><code>thread apply [thread-id-list | all] &lt;command&gt;</code>，在一些线程上执行命令。(不常用)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB Convenience Variables</title>
      <link href="/2024/05/01/linux-gdb-convenience-var/"/>
      <url>/2024/05/01/linux-gdb-convenience-var/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h1><ul><li><p>形式为以<code>$</code>开头的名字(以<code>$</code>开头的数字不是)</p></li><li><p>无固定类型，甚至可以是结构体或者数组</p></li></ul><h1 id="2-赋值"><a href="#2-赋值" class="headerlink" title="2. 赋值"></a>2. 赋值</h1><p>使用<code>set</code>命令，如<code>set $foo = *object_ptr</code></p><h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h1><p>不断使用回车遍历数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $i = 0</span><br><span class="line">p arr[$i++]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux GDB TUI(Text User Interface)</title>
      <link href="/2024/05/01/linux-gdb-tui/"/>
      <url>/2024/05/01/linux-gdb-tui/</url>
      
        <content type="html"><![CDATA[<h1 id="1-GDB-tui常用命令"><a href="#1-GDB-tui常用命令" class="headerlink" title="1. GDB tui常用命令"></a>1. GDB tui常用命令</h1><h2 id="1-1-启动和退出tui模式"><a href="#1-1-启动和退出tui模式" class="headerlink" title="1.1 启动和退出tui模式"></a>1.1 启动和退出tui模式</h2><ul><li><p>分别是<code>tui enable</code>(缩写为<code>tui e</code>)和<code>tui disable</code>(缩写为<code>tui d</code>)命令</p></li><li><p>或者使用快捷键ctrl+x+a，按第一次进入，第二次退出</p></li></ul><h2 id="1-2-ctrl-L-刷新屏幕"><a href="#1-2-ctrl-L-刷新屏幕" class="headerlink" title="1.2 ctrl+L 刷新屏幕"></a>1.2 ctrl+L 刷新屏幕</h2><p>在程序使用标准输出和标准错误打印时屏幕可能乱掉，可以使用ctrl+L进行刷新</p><p>ctrl+L不会被记在命令历史里，下一次ENTER不会重复ctrl+L</p><h2 id="1-3-info-win命令"><a href="#1-3-info-win命令" class="headerlink" title="1.3 info win命令"></a>1.3 <code>info win</code>命令</h2><p>列出当前显示的所有窗口</p><h2 id="1-4-focus命令"><a href="#1-4-focus命令" class="headerlink" title="1.4 focus命令"></a>1.4 <code>focus</code>命令</h2><p>缩写为<code>fs</code>，改变焦点到不同窗口，使用方式<code>focus [WINDOW-NAME | next | prev]</code></p><h2 id="1-5-查看文档"><a href="#1-5-查看文档" class="headerlink" title="1.5 查看文档"></a>1.5 查看文档</h2><p>使用<code>help text-user-interface</code>查看tui相关所有命令</p><h1 id="2-CGDB"><a href="#2-CGDB" class="headerlink" title="2. CGDB"></a>2. CGDB</h1><p>CGDB是GDB的一个控制台前端(Console Frontend)，它还是使用GDB进行实际调试</p><p>GDB的tui模式不支持源码窗口和命令窗口垂直分屏，因此使用CGDB</p><h2 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用"></a>2.1 使用</h2><h4 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h4><p>在shell中输入<code>cgdb</code>启动程序</p><p>调用方式类似GDB: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgdb [cgdb options] [--] [gdb options]</span><br></pre></td></tr></table></figure><h4 id="2-退出"><a href="#2-退出" class="headerlink" title="2. 退出"></a>2. 退出</h4><ul><li><p>在GDB窗口输入<code>quit</code>或者ctrl+D</p></li><li><p>在源代码窗口输入<code>:quit</code></p></li></ul><h4 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a>3. 调试</h4><p>CGDB的操作类似vim，按<code>ESC</code>键进入源代码窗口，按<code>i</code>进入GDB窗口</p><h4 id="4-垂直分屏"><a href="#4-垂直分屏" class="headerlink" title="4. 垂直分屏"></a>4. 垂直分屏</h4><p>源代码和命令窗口垂直分屏输入：</p><p><code>:set winsplitorientation=vertical</code>或者<code>:set wso=vertical</code></p><h4 id="5-cgdb-cgdbrc文件"><a href="#5-cgdb-cgdbrc文件" class="headerlink" title="5. ~/.cgdb/cgdbrc文件"></a>5. <code>~/.cgdb/cgdbrc</code>文件</h4><p>类似于<code>!/.bashrc</code>文件，用于初始化cgdb，可将<code>:set wso=vertical</code>写入以默认垂直分屏</p><h2 id="2-2-资源"><a href="#2-2-资源" class="headerlink" title="2.2 资源"></a>2.2 资源</h2><ul><li><p><a href="https://cgdb.github.io/">官网</a></p></li><li><p><a href="https://cgdb.github.io/docs/cgdb-split.html">文档</a></p></li></ul><h2 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h2><ul><li>目前最新版为0.8.0，没有发正式版</li></ul>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过邺下吊高神武</title>
      <link href="/2024/05/01/%E8%BF%87%E9%82%BA%E4%B8%8B%E5%90%8A%E9%AB%98%E7%A5%9E%E6%AD%A6/"/>
      <url>/2024/05/01/%E8%BF%87%E9%82%BA%E4%B8%8B%E5%90%8A%E9%AB%98%E7%A5%9E%E6%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">过邺下吊高神武</p></h1><h3><p style="text-align: center;">[清] 袁枚</p></h3><h2><p style="text-align: center;">唱罢阴山敕勒歌，英雄涕泪老来多。</p></h2><h2><p style="text-align: center;">生持魏武朝天笏，死授条侯杀贼戈。</p></h2><h2><p style="text-align: center;">六镇华夷传露布，九龙风雨聚漳河。</p></h2><h2><p style="text-align: center;">祇今尚有清流月，曾照高王万马过。</p></h2>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux查看二进制文件内容</title>
      <link href="/2024/04/24/linux-check-binary-file/"/>
      <url>/2024/04/24/linux-check-binary-file/</url>
      
        <content type="html"><![CDATA[<h1 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C &lt;file&gt;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hd &lt;file&gt;</span><br></pre></td></tr></table></figure><p><code>hd</code>是<code>hexdump</code>的符号链接</p>]]></content>
      
      
      <categories>
          
          <category> computer_science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临江仙·夜归临皋</title>
      <link href="/2023/04/01/%E4%B8%B4%E6%B1%9F%E4%BB%99%E5%A4%9C%E5%BD%92%E4%B8%B4%E7%9A%8B/"/>
      <url>/2023/04/01/%E4%B8%B4%E6%B1%9F%E4%BB%99%E5%A4%9C%E5%BD%92%E4%B8%B4%E7%9A%8B/</url>
      
        <content type="html"><![CDATA[<h1><p style="text-align: center;">临江仙·夜归临皋</p></h1><h3><p style="text-align: center;">[宋] 苏轼</p></h3><h3><p style="text-align: center;">夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。</p></h3><h3><p style="text-align: center;">长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。</p></h3>]]></content>
      
      
      <categories>
          
          <category> literature(文学) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> poem(诗歌) </tag>
            
            <tag> excerpt(摘抄) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
